// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Gets information about the user, the user's Drive, and system capabilities.
    ///
    /// - Remark: HTTP `GET /about`.
    /// - Remark: Generated from `#/paths//about/get(drive.about.get)`.
    func drive_about_get(_ input: Operations.Drive_about_get.Input) async throws -> Operations.Drive_about_get.Output
    /// Lists a user's installed apps.
    ///
    /// - Remark: HTTP `GET /apps`.
    /// - Remark: Generated from `#/paths//apps/get(drive.apps.list)`.
    func drive_apps_list(_ input: Operations.Drive_apps_list.Input) async throws -> Operations.Drive_apps_list.Output
    /// Gets a specific app.
    ///
    /// - Remark: HTTP `GET /apps/{appId}`.
    /// - Remark: Generated from `#/paths//apps/{appId}/get(drive.apps.get)`.
    func drive_apps_get(_ input: Operations.Drive_apps_get.Input) async throws -> Operations.Drive_apps_get.Output
    /// Lists the changes for a user or shared drive.
    ///
    /// - Remark: HTTP `GET /changes`.
    /// - Remark: Generated from `#/paths//changes/get(drive.changes.list)`.
    func drive_changes_list(_ input: Operations.Drive_changes_list.Input) async throws -> Operations.Drive_changes_list.Output
    /// Gets the starting pageToken for listing future changes.
    ///
    /// - Remark: HTTP `GET /changes/startPageToken`.
    /// - Remark: Generated from `#/paths//changes/startPageToken/get(drive.changes.getStartPageToken)`.
    func drive_changes_getStartPageToken(_ input: Operations.Drive_changes_getStartPageToken.Input) async throws -> Operations.Drive_changes_getStartPageToken.Output
    /// Subscribes to changes for a user.
    ///
    /// - Remark: HTTP `POST /changes/watch`.
    /// - Remark: Generated from `#/paths//changes/watch/post(drive.changes.watch)`.
    func drive_changes_watch(_ input: Operations.Drive_changes_watch.Input) async throws -> Operations.Drive_changes_watch.Output
    /// Stops watching resources through this channel.
    ///
    /// - Remark: HTTP `POST /channels/stop`.
    /// - Remark: Generated from `#/paths//channels/stop/post(drive.channels.stop)`.
    func drive_channels_stop(_ input: Operations.Drive_channels_stop.Input) async throws -> Operations.Drive_channels_stop.Output
    ///  Lists the user's shared drives. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for shared drives](/drive/api/guides/search-shareddrives) guide.
    ///
    /// - Remark: HTTP `GET /drives`.
    /// - Remark: Generated from `#/paths//drives/get(drive.drives.list)`.
    func drive_drives_list(_ input: Operations.Drive_drives_list.Input) async throws -> Operations.Drive_drives_list.Output
    /// Creates a shared drive.
    ///
    /// - Remark: HTTP `POST /drives`.
    /// - Remark: Generated from `#/paths//drives/post(drive.drives.create)`.
    func drive_drives_create(_ input: Operations.Drive_drives_create.Input) async throws -> Operations.Drive_drives_create.Output
    /// Gets a shared drive's metadata by ID.
    ///
    /// - Remark: HTTP `GET /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/get(drive.drives.get)`.
    func drive_drives_get(_ input: Operations.Drive_drives_get.Input) async throws -> Operations.Drive_drives_get.Output
    /// Updates the metadate for a shared drive.
    ///
    /// - Remark: HTTP `PATCH /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/patch(drive.drives.update)`.
    func drive_drives_update(_ input: Operations.Drive_drives_update.Input) async throws -> Operations.Drive_drives_update.Output
    /// Permanently deletes a shared drive for which the user is an `organizer`. The shared drive cannot contain any untrashed items.
    ///
    /// - Remark: HTTP `DELETE /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/delete(drive.drives.delete)`.
    func drive_drives_delete(_ input: Operations.Drive_drives_delete.Input) async throws -> Operations.Drive_drives_delete.Output
    /// Hides a shared drive from the default view.
    ///
    /// - Remark: HTTP `POST /drives/{driveId}/hide`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/hide/post(drive.drives.hide)`.
    func drive_drives_hide(_ input: Operations.Drive_drives_hide.Input) async throws -> Operations.Drive_drives_hide.Output
    /// Restores a shared drive to the default view.
    ///
    /// - Remark: HTTP `POST /drives/{driveId}/unhide`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/unhide/post(drive.drives.unhide)`.
    func drive_drives_unhide(_ input: Operations.Drive_drives_unhide.Input) async throws -> Operations.Drive_drives_unhide.Output
    ///  Lists the user's files. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for files & folders](/drive/api/guides/search-files) guide. *Note:* This method returns *all* files by default, including trashed files. If you don't want trashed files to appear in the list, use the `trashed=false` query parameter to remove trashed files from the results.
    ///
    /// - Remark: HTTP `GET /files`.
    /// - Remark: Generated from `#/paths//files/get(drive.files.list)`.
    func drive_files_list(_ input: Operations.Drive_files_list.Input) async throws -> Operations.Drive_files_list.Output
    ///  Creates a new file. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads). Apps creating shortcuts with `files.create` must specify the MIME type `application/vnd.google-apps.shortcut`. Apps should specify a file extension in the `name` property when inserting files with the API. For example, an operation to insert a JPEG file should specify something like `"name": "cat.jpg"` in the metadata. Subsequent `GET` requests include the read-only `fileExtension` property populated with the extension originally specified in the `title` property. When a Google Drive user requests to download a file, or when the file is downloaded through the sync client, Drive builds a full filename (with extension) based on the title. In cases where the extension is missing, Drive attempts to determine the extension based on the file's MIME type.
    ///
    /// - Remark: HTTP `POST /files`.
    /// - Remark: Generated from `#/paths//files/post(drive.files.create)`.
    func drive_files_create(_ input: Operations.Drive_files_create.Input) async throws -> Operations.Drive_files_create.Output
    /// Generates a set of file IDs which can be provided in create or copy requests.
    ///
    /// - Remark: HTTP `GET /files/generateIds`.
    /// - Remark: Generated from `#/paths//files/generateIds/get(drive.files.generateIds)`.
    func drive_files_generateIds(_ input: Operations.Drive_files_generateIds.Input) async throws -> Operations.Drive_files_generateIds.Output
    /// Permanently deletes all of the user's trashed files.
    ///
    /// - Remark: HTTP `DELETE /files/trash`.
    /// - Remark: Generated from `#/paths//files/trash/delete(drive.files.emptyTrash)`.
    func drive_files_emptyTrash(_ input: Operations.Drive_files_emptyTrash.Input) async throws -> Operations.Drive_files_emptyTrash.Output
    ///  Gets a file's metadata or content by ID. If you provide the URL parameter `alt=media`, then the response includes the file contents in the response body. Downloading content with `alt=media` only works if the file is stored in Drive. To download Google Docs, Sheets, and Slides use [`files.export`](/drive/api/reference/rest/v3/files/export) instead. For more information, see [Download & export files](/drive/api/guides/manage-downloads).
    ///
    /// - Remark: HTTP `GET /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/get(drive.files.get)`.
    func drive_files_get(_ input: Operations.Drive_files_get.Input) async throws -> Operations.Drive_files_get.Output
    ///  Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as `modifiedDate`. This method supports patch semantics. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads).
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/patch(drive.files.update)`.
    func drive_files_update(_ input: Operations.Drive_files_update.Input) async throws -> Operations.Drive_files_update.Output
    /// Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive, the user must be an `organizer` on the parent folder. If the target is a folder, all descendants owned by the user are also deleted.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/delete(drive.files.delete)`.
    func drive_files_delete(_ input: Operations.Drive_files_delete.Input) async throws -> Operations.Drive_files_delete.Output
    /// Lists a file's comments.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/get(drive.comments.list)`.
    func drive_comments_list(_ input: Operations.Drive_comments_list.Input) async throws -> Operations.Drive_comments_list.Output
    /// Creates a comment on a file.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/comments`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/post(drive.comments.create)`.
    func drive_comments_create(_ input: Operations.Drive_comments_create.Input) async throws -> Operations.Drive_comments_create.Output
    /// Gets a comment by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/get(drive.comments.get)`.
    func drive_comments_get(_ input: Operations.Drive_comments_get.Input) async throws -> Operations.Drive_comments_get.Output
    /// Updates a comment with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/patch(drive.comments.update)`.
    func drive_comments_update(_ input: Operations.Drive_comments_update.Input) async throws -> Operations.Drive_comments_update.Output
    /// Deletes a comment.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/delete(drive.comments.delete)`.
    func drive_comments_delete(_ input: Operations.Drive_comments_delete.Input) async throws -> Operations.Drive_comments_delete.Output
    /// Lists a comment's replies.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}/replies`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/get(drive.replies.list)`.
    func drive_replies_list(_ input: Operations.Drive_replies_list.Input) async throws -> Operations.Drive_replies_list.Output
    /// Creates a reply to a comment.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/comments/{commentId}/replies`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/post(drive.replies.create)`.
    func drive_replies_create(_ input: Operations.Drive_replies_create.Input) async throws -> Operations.Drive_replies_create.Output
    /// Gets a reply by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/get(drive.replies.get)`.
    func drive_replies_get(_ input: Operations.Drive_replies_get.Input) async throws -> Operations.Drive_replies_get.Output
    /// Updates a reply with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/patch(drive.replies.update)`.
    func drive_replies_update(_ input: Operations.Drive_replies_update.Input) async throws -> Operations.Drive_replies_update.Output
    /// Deletes a reply.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/delete(drive.replies.delete)`.
    func drive_replies_delete(_ input: Operations.Drive_replies_delete.Input) async throws -> Operations.Drive_replies_delete.Output
    /// Creates a copy of a file and applies any requested updates with patch semantics.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/copy`.
    /// - Remark: Generated from `#/paths//files/{fileId}/copy/post(drive.files.copy)`.
    func drive_files_copy(_ input: Operations.Drive_files_copy.Input) async throws -> Operations.Drive_files_copy.Output
    /// Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/export`.
    /// - Remark: Generated from `#/paths//files/{fileId}/export/get(drive.files.export)`.
    func drive_files_export(_ input: Operations.Drive_files_export.Input) async throws -> Operations.Drive_files_export.Output
    /// Lists the labels on a file.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/listLabels`.
    /// - Remark: Generated from `#/paths//files/{fileId}/listLabels/get(drive.files.listLabels)`.
    func drive_files_listLabels(_ input: Operations.Drive_files_listLabels.Input) async throws -> Operations.Drive_files_listLabels.Output
    /// Modifies the set of labels applied to a file. Returns a list of the labels that were added or modified.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/modifyLabels`.
    /// - Remark: Generated from `#/paths//files/{fileId}/modifyLabels/post(drive.files.modifyLabels)`.
    func drive_files_modifyLabels(_ input: Operations.Drive_files_modifyLabels.Input) async throws -> Operations.Drive_files_modifyLabels.Output
    /// Lists a file's or shared drive's permissions.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/permissions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/get(drive.permissions.list)`.
    func drive_permissions_list(_ input: Operations.Drive_permissions_list.Input) async throws -> Operations.Drive_permissions_list.Output
    /// Creates a permission for a file or shared drive. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/permissions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/post(drive.permissions.create)`.
    func drive_permissions_create(_ input: Operations.Drive_permissions_create.Input) async throws -> Operations.Drive_permissions_create.Output
    /// Gets a permission by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/get(drive.permissions.get)`.
    func drive_permissions_get(_ input: Operations.Drive_permissions_get.Input) async throws -> Operations.Drive_permissions_get.Output
    /// Updates a permission with patch semantics. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/patch(drive.permissions.update)`.
    func drive_permissions_update(_ input: Operations.Drive_permissions_update.Input) async throws -> Operations.Drive_permissions_update.Output
    /// Deletes a permission. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/delete(drive.permissions.delete)`.
    func drive_permissions_delete(_ input: Operations.Drive_permissions_delete.Input) async throws -> Operations.Drive_permissions_delete.Output
    /// Lists a file's revisions.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/revisions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/get(drive.revisions.list)`.
    func drive_revisions_list(_ input: Operations.Drive_revisions_list.Input) async throws -> Operations.Drive_revisions_list.Output
    /// Gets a revision's metadata or content by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/get(drive.revisions.get)`.
    func drive_revisions_get(_ input: Operations.Drive_revisions_get.Input) async throws -> Operations.Drive_revisions_get.Output
    /// Updates a revision with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/patch(drive.revisions.update)`.
    func drive_revisions_update(_ input: Operations.Drive_revisions_update.Input) async throws -> Operations.Drive_revisions_update.Output
    /// Permanently deletes a file version. You can only delete revisions for files with binary content in Google Drive, like images or videos. Revisions for other files, like Google Docs or Sheets, and the last remaining file version can't be deleted.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/delete(drive.revisions.delete)`.
    func drive_revisions_delete(_ input: Operations.Drive_revisions_delete.Input) async throws -> Operations.Drive_revisions_delete.Output
    /// Subscribes to changes to a file.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/watch`.
    /// - Remark: Generated from `#/paths//files/{fileId}/watch/post(drive.files.watch)`.
    func drive_files_watch(_ input: Operations.Drive_files_watch.Input) async throws -> Operations.Drive_files_watch.Output
    /// Deprecated: Use `drives.list` instead.
    ///
    /// - Remark: HTTP `GET /teamdrives`.
    /// - Remark: Generated from `#/paths//teamdrives/get(drive.teamdrives.list)`.
    func drive_teamdrives_list(_ input: Operations.Drive_teamdrives_list.Input) async throws -> Operations.Drive_teamdrives_list.Output
    /// Deprecated: Use `drives.create` instead.
    ///
    /// - Remark: HTTP `POST /teamdrives`.
    /// - Remark: Generated from `#/paths//teamdrives/post(drive.teamdrives.create)`.
    func drive_teamdrives_create(_ input: Operations.Drive_teamdrives_create.Input) async throws -> Operations.Drive_teamdrives_create.Output
    /// Deprecated: Use `drives.get` instead.
    ///
    /// - Remark: HTTP `GET /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/get(drive.teamdrives.get)`.
    func drive_teamdrives_get(_ input: Operations.Drive_teamdrives_get.Input) async throws -> Operations.Drive_teamdrives_get.Output
    /// Deprecated: Use `drives.update` instead.
    ///
    /// - Remark: HTTP `PATCH /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/patch(drive.teamdrives.update)`.
    func drive_teamdrives_update(_ input: Operations.Drive_teamdrives_update.Input) async throws -> Operations.Drive_teamdrives_update.Output
    /// Deprecated: Use `drives.delete` instead.
    ///
    /// - Remark: HTTP `DELETE /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/delete(drive.teamdrives.delete)`.
    func drive_teamdrives_delete(_ input: Operations.Drive_teamdrives_delete.Input) async throws -> Operations.Drive_teamdrives_delete.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Gets information about the user, the user's Drive, and system capabilities.
    ///
    /// - Remark: HTTP `GET /about`.
    /// - Remark: Generated from `#/paths//about/get(drive.about.get)`.
    public func drive_about_get(
        query: Operations.Drive_about_get.Input.Query = .init(),
        headers: Operations.Drive_about_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_about_get.Output {
        try await drive_about_get(Operations.Drive_about_get.Input(
            query: query,
            headers: headers
        ))
    }
    /// Lists a user's installed apps.
    ///
    /// - Remark: HTTP `GET /apps`.
    /// - Remark: Generated from `#/paths//apps/get(drive.apps.list)`.
    public func drive_apps_list(
        query: Operations.Drive_apps_list.Input.Query = .init(),
        headers: Operations.Drive_apps_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_apps_list.Output {
        try await drive_apps_list(Operations.Drive_apps_list.Input(
            query: query,
            headers: headers
        ))
    }
    /// Gets a specific app.
    ///
    /// - Remark: HTTP `GET /apps/{appId}`.
    /// - Remark: Generated from `#/paths//apps/{appId}/get(drive.apps.get)`.
    public func drive_apps_get(
        path: Operations.Drive_apps_get.Input.Path,
        query: Operations.Drive_apps_get.Input.Query = .init(),
        headers: Operations.Drive_apps_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_apps_get.Output {
        try await drive_apps_get(Operations.Drive_apps_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Lists the changes for a user or shared drive.
    ///
    /// - Remark: HTTP `GET /changes`.
    /// - Remark: Generated from `#/paths//changes/get(drive.changes.list)`.
    public func drive_changes_list(
        query: Operations.Drive_changes_list.Input.Query,
        headers: Operations.Drive_changes_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_changes_list.Output {
        try await drive_changes_list(Operations.Drive_changes_list.Input(
            query: query,
            headers: headers
        ))
    }
    /// Gets the starting pageToken for listing future changes.
    ///
    /// - Remark: HTTP `GET /changes/startPageToken`.
    /// - Remark: Generated from `#/paths//changes/startPageToken/get(drive.changes.getStartPageToken)`.
    public func drive_changes_getStartPageToken(
        query: Operations.Drive_changes_getStartPageToken.Input.Query = .init(),
        headers: Operations.Drive_changes_getStartPageToken.Input.Headers = .init()
    ) async throws -> Operations.Drive_changes_getStartPageToken.Output {
        try await drive_changes_getStartPageToken(Operations.Drive_changes_getStartPageToken.Input(
            query: query,
            headers: headers
        ))
    }
    /// Subscribes to changes for a user.
    ///
    /// - Remark: HTTP `POST /changes/watch`.
    /// - Remark: Generated from `#/paths//changes/watch/post(drive.changes.watch)`.
    public func drive_changes_watch(
        query: Operations.Drive_changes_watch.Input.Query,
        headers: Operations.Drive_changes_watch.Input.Headers = .init(),
        body: Operations.Drive_changes_watch.Input.Body? = nil
    ) async throws -> Operations.Drive_changes_watch.Output {
        try await drive_changes_watch(Operations.Drive_changes_watch.Input(
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Stops watching resources through this channel.
    ///
    /// - Remark: HTTP `POST /channels/stop`.
    /// - Remark: Generated from `#/paths//channels/stop/post(drive.channels.stop)`.
    public func drive_channels_stop(
        query: Operations.Drive_channels_stop.Input.Query = .init(),
        body: Operations.Drive_channels_stop.Input.Body? = nil
    ) async throws -> Operations.Drive_channels_stop.Output {
        try await drive_channels_stop(Operations.Drive_channels_stop.Input(
            query: query,
            body: body
        ))
    }
    ///  Lists the user's shared drives. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for shared drives](/drive/api/guides/search-shareddrives) guide.
    ///
    /// - Remark: HTTP `GET /drives`.
    /// - Remark: Generated from `#/paths//drives/get(drive.drives.list)`.
    public func drive_drives_list(
        query: Operations.Drive_drives_list.Input.Query = .init(),
        headers: Operations.Drive_drives_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_drives_list.Output {
        try await drive_drives_list(Operations.Drive_drives_list.Input(
            query: query,
            headers: headers
        ))
    }
    /// Creates a shared drive.
    ///
    /// - Remark: HTTP `POST /drives`.
    /// - Remark: Generated from `#/paths//drives/post(drive.drives.create)`.
    public func drive_drives_create(
        query: Operations.Drive_drives_create.Input.Query,
        headers: Operations.Drive_drives_create.Input.Headers = .init(),
        body: Operations.Drive_drives_create.Input.Body? = nil
    ) async throws -> Operations.Drive_drives_create.Output {
        try await drive_drives_create(Operations.Drive_drives_create.Input(
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Gets a shared drive's metadata by ID.
    ///
    /// - Remark: HTTP `GET /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/get(drive.drives.get)`.
    public func drive_drives_get(
        path: Operations.Drive_drives_get.Input.Path,
        query: Operations.Drive_drives_get.Input.Query = .init(),
        headers: Operations.Drive_drives_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_drives_get.Output {
        try await drive_drives_get(Operations.Drive_drives_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Updates the metadate for a shared drive.
    ///
    /// - Remark: HTTP `PATCH /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/patch(drive.drives.update)`.
    public func drive_drives_update(
        path: Operations.Drive_drives_update.Input.Path,
        query: Operations.Drive_drives_update.Input.Query = .init(),
        headers: Operations.Drive_drives_update.Input.Headers = .init(),
        body: Operations.Drive_drives_update.Input.Body? = nil
    ) async throws -> Operations.Drive_drives_update.Output {
        try await drive_drives_update(Operations.Drive_drives_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Permanently deletes a shared drive for which the user is an `organizer`. The shared drive cannot contain any untrashed items.
    ///
    /// - Remark: HTTP `DELETE /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/delete(drive.drives.delete)`.
    public func drive_drives_delete(
        path: Operations.Drive_drives_delete.Input.Path,
        query: Operations.Drive_drives_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_drives_delete.Output {
        try await drive_drives_delete(Operations.Drive_drives_delete.Input(
            path: path,
            query: query
        ))
    }
    /// Hides a shared drive from the default view.
    ///
    /// - Remark: HTTP `POST /drives/{driveId}/hide`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/hide/post(drive.drives.hide)`.
    public func drive_drives_hide(
        path: Operations.Drive_drives_hide.Input.Path,
        query: Operations.Drive_drives_hide.Input.Query = .init(),
        headers: Operations.Drive_drives_hide.Input.Headers = .init()
    ) async throws -> Operations.Drive_drives_hide.Output {
        try await drive_drives_hide(Operations.Drive_drives_hide.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Restores a shared drive to the default view.
    ///
    /// - Remark: HTTP `POST /drives/{driveId}/unhide`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/unhide/post(drive.drives.unhide)`.
    public func drive_drives_unhide(
        path: Operations.Drive_drives_unhide.Input.Path,
        query: Operations.Drive_drives_unhide.Input.Query = .init(),
        headers: Operations.Drive_drives_unhide.Input.Headers = .init()
    ) async throws -> Operations.Drive_drives_unhide.Output {
        try await drive_drives_unhide(Operations.Drive_drives_unhide.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    ///  Lists the user's files. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for files & folders](/drive/api/guides/search-files) guide. *Note:* This method returns *all* files by default, including trashed files. If you don't want trashed files to appear in the list, use the `trashed=false` query parameter to remove trashed files from the results.
    ///
    /// - Remark: HTTP `GET /files`.
    /// - Remark: Generated from `#/paths//files/get(drive.files.list)`.
    public func drive_files_list(
        query: Operations.Drive_files_list.Input.Query = .init(),
        headers: Operations.Drive_files_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_files_list.Output {
        try await drive_files_list(Operations.Drive_files_list.Input(
            query: query,
            headers: headers
        ))
    }
    ///  Creates a new file. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads). Apps creating shortcuts with `files.create` must specify the MIME type `application/vnd.google-apps.shortcut`. Apps should specify a file extension in the `name` property when inserting files with the API. For example, an operation to insert a JPEG file should specify something like `"name": "cat.jpg"` in the metadata. Subsequent `GET` requests include the read-only `fileExtension` property populated with the extension originally specified in the `title` property. When a Google Drive user requests to download a file, or when the file is downloaded through the sync client, Drive builds a full filename (with extension) based on the title. In cases where the extension is missing, Drive attempts to determine the extension based on the file's MIME type.
    ///
    /// - Remark: HTTP `POST /files`.
    /// - Remark: Generated from `#/paths//files/post(drive.files.create)`.
    public func drive_files_create(
        query: Operations.Drive_files_create.Input.Query = .init(),
        headers: Operations.Drive_files_create.Input.Headers = .init(),
        body: Operations.Drive_files_create.Input.Body? = nil
    ) async throws -> Operations.Drive_files_create.Output {
        try await drive_files_create(Operations.Drive_files_create.Input(
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Generates a set of file IDs which can be provided in create or copy requests.
    ///
    /// - Remark: HTTP `GET /files/generateIds`.
    /// - Remark: Generated from `#/paths//files/generateIds/get(drive.files.generateIds)`.
    public func drive_files_generateIds(
        query: Operations.Drive_files_generateIds.Input.Query = .init(),
        headers: Operations.Drive_files_generateIds.Input.Headers = .init()
    ) async throws -> Operations.Drive_files_generateIds.Output {
        try await drive_files_generateIds(Operations.Drive_files_generateIds.Input(
            query: query,
            headers: headers
        ))
    }
    /// Permanently deletes all of the user's trashed files.
    ///
    /// - Remark: HTTP `DELETE /files/trash`.
    /// - Remark: Generated from `#/paths//files/trash/delete(drive.files.emptyTrash)`.
    public func drive_files_emptyTrash(query: Operations.Drive_files_emptyTrash.Input.Query = .init()) async throws -> Operations.Drive_files_emptyTrash.Output {
        try await drive_files_emptyTrash(Operations.Drive_files_emptyTrash.Input(query: query))
    }
    ///  Gets a file's metadata or content by ID. If you provide the URL parameter `alt=media`, then the response includes the file contents in the response body. Downloading content with `alt=media` only works if the file is stored in Drive. To download Google Docs, Sheets, and Slides use [`files.export`](/drive/api/reference/rest/v3/files/export) instead. For more information, see [Download & export files](/drive/api/guides/manage-downloads).
    ///
    /// - Remark: HTTP `GET /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/get(drive.files.get)`.
    public func drive_files_get(
        path: Operations.Drive_files_get.Input.Path,
        query: Operations.Drive_files_get.Input.Query = .init(),
        headers: Operations.Drive_files_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_files_get.Output {
        try await drive_files_get(Operations.Drive_files_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    ///  Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as `modifiedDate`. This method supports patch semantics. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads).
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/patch(drive.files.update)`.
    public func drive_files_update(
        path: Operations.Drive_files_update.Input.Path,
        query: Operations.Drive_files_update.Input.Query = .init(),
        headers: Operations.Drive_files_update.Input.Headers = .init(),
        body: Operations.Drive_files_update.Input.Body? = nil
    ) async throws -> Operations.Drive_files_update.Output {
        try await drive_files_update(Operations.Drive_files_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive, the user must be an `organizer` on the parent folder. If the target is a folder, all descendants owned by the user are also deleted.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/delete(drive.files.delete)`.
    public func drive_files_delete(
        path: Operations.Drive_files_delete.Input.Path,
        query: Operations.Drive_files_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_files_delete.Output {
        try await drive_files_delete(Operations.Drive_files_delete.Input(
            path: path,
            query: query
        ))
    }
    /// Lists a file's comments.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/get(drive.comments.list)`.
    public func drive_comments_list(
        path: Operations.Drive_comments_list.Input.Path,
        query: Operations.Drive_comments_list.Input.Query = .init(),
        headers: Operations.Drive_comments_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_comments_list.Output {
        try await drive_comments_list(Operations.Drive_comments_list.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Creates a comment on a file.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/comments`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/post(drive.comments.create)`.
    public func drive_comments_create(
        path: Operations.Drive_comments_create.Input.Path,
        query: Operations.Drive_comments_create.Input.Query = .init(),
        headers: Operations.Drive_comments_create.Input.Headers = .init(),
        body: Operations.Drive_comments_create.Input.Body? = nil
    ) async throws -> Operations.Drive_comments_create.Output {
        try await drive_comments_create(Operations.Drive_comments_create.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Gets a comment by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/get(drive.comments.get)`.
    public func drive_comments_get(
        path: Operations.Drive_comments_get.Input.Path,
        query: Operations.Drive_comments_get.Input.Query = .init(),
        headers: Operations.Drive_comments_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_comments_get.Output {
        try await drive_comments_get(Operations.Drive_comments_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Updates a comment with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/patch(drive.comments.update)`.
    public func drive_comments_update(
        path: Operations.Drive_comments_update.Input.Path,
        query: Operations.Drive_comments_update.Input.Query = .init(),
        headers: Operations.Drive_comments_update.Input.Headers = .init(),
        body: Operations.Drive_comments_update.Input.Body? = nil
    ) async throws -> Operations.Drive_comments_update.Output {
        try await drive_comments_update(Operations.Drive_comments_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Deletes a comment.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/delete(drive.comments.delete)`.
    public func drive_comments_delete(
        path: Operations.Drive_comments_delete.Input.Path,
        query: Operations.Drive_comments_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_comments_delete.Output {
        try await drive_comments_delete(Operations.Drive_comments_delete.Input(
            path: path,
            query: query
        ))
    }
    /// Lists a comment's replies.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}/replies`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/get(drive.replies.list)`.
    public func drive_replies_list(
        path: Operations.Drive_replies_list.Input.Path,
        query: Operations.Drive_replies_list.Input.Query = .init(),
        headers: Operations.Drive_replies_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_replies_list.Output {
        try await drive_replies_list(Operations.Drive_replies_list.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Creates a reply to a comment.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/comments/{commentId}/replies`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/post(drive.replies.create)`.
    public func drive_replies_create(
        path: Operations.Drive_replies_create.Input.Path,
        query: Operations.Drive_replies_create.Input.Query = .init(),
        headers: Operations.Drive_replies_create.Input.Headers = .init(),
        body: Operations.Drive_replies_create.Input.Body? = nil
    ) async throws -> Operations.Drive_replies_create.Output {
        try await drive_replies_create(Operations.Drive_replies_create.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Gets a reply by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/get(drive.replies.get)`.
    public func drive_replies_get(
        path: Operations.Drive_replies_get.Input.Path,
        query: Operations.Drive_replies_get.Input.Query = .init(),
        headers: Operations.Drive_replies_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_replies_get.Output {
        try await drive_replies_get(Operations.Drive_replies_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Updates a reply with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/patch(drive.replies.update)`.
    public func drive_replies_update(
        path: Operations.Drive_replies_update.Input.Path,
        query: Operations.Drive_replies_update.Input.Query = .init(),
        headers: Operations.Drive_replies_update.Input.Headers = .init(),
        body: Operations.Drive_replies_update.Input.Body? = nil
    ) async throws -> Operations.Drive_replies_update.Output {
        try await drive_replies_update(Operations.Drive_replies_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Deletes a reply.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/delete(drive.replies.delete)`.
    public func drive_replies_delete(
        path: Operations.Drive_replies_delete.Input.Path,
        query: Operations.Drive_replies_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_replies_delete.Output {
        try await drive_replies_delete(Operations.Drive_replies_delete.Input(
            path: path,
            query: query
        ))
    }
    /// Creates a copy of a file and applies any requested updates with patch semantics.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/copy`.
    /// - Remark: Generated from `#/paths//files/{fileId}/copy/post(drive.files.copy)`.
    public func drive_files_copy(
        path: Operations.Drive_files_copy.Input.Path,
        query: Operations.Drive_files_copy.Input.Query = .init(),
        headers: Operations.Drive_files_copy.Input.Headers = .init(),
        body: Operations.Drive_files_copy.Input.Body? = nil
    ) async throws -> Operations.Drive_files_copy.Output {
        try await drive_files_copy(Operations.Drive_files_copy.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/export`.
    /// - Remark: Generated from `#/paths//files/{fileId}/export/get(drive.files.export)`.
    public func drive_files_export(
        path: Operations.Drive_files_export.Input.Path,
        query: Operations.Drive_files_export.Input.Query
    ) async throws -> Operations.Drive_files_export.Output {
        try await drive_files_export(Operations.Drive_files_export.Input(
            path: path,
            query: query
        ))
    }
    /// Lists the labels on a file.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/listLabels`.
    /// - Remark: Generated from `#/paths//files/{fileId}/listLabels/get(drive.files.listLabels)`.
    public func drive_files_listLabels(
        path: Operations.Drive_files_listLabels.Input.Path,
        query: Operations.Drive_files_listLabels.Input.Query = .init(),
        headers: Operations.Drive_files_listLabels.Input.Headers = .init()
    ) async throws -> Operations.Drive_files_listLabels.Output {
        try await drive_files_listLabels(Operations.Drive_files_listLabels.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Modifies the set of labels applied to a file. Returns a list of the labels that were added or modified.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/modifyLabels`.
    /// - Remark: Generated from `#/paths//files/{fileId}/modifyLabels/post(drive.files.modifyLabels)`.
    public func drive_files_modifyLabels(
        path: Operations.Drive_files_modifyLabels.Input.Path,
        query: Operations.Drive_files_modifyLabels.Input.Query = .init(),
        headers: Operations.Drive_files_modifyLabels.Input.Headers = .init(),
        body: Operations.Drive_files_modifyLabels.Input.Body? = nil
    ) async throws -> Operations.Drive_files_modifyLabels.Output {
        try await drive_files_modifyLabels(Operations.Drive_files_modifyLabels.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Lists a file's or shared drive's permissions.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/permissions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/get(drive.permissions.list)`.
    public func drive_permissions_list(
        path: Operations.Drive_permissions_list.Input.Path,
        query: Operations.Drive_permissions_list.Input.Query = .init(),
        headers: Operations.Drive_permissions_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_permissions_list.Output {
        try await drive_permissions_list(Operations.Drive_permissions_list.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Creates a permission for a file or shared drive. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/permissions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/post(drive.permissions.create)`.
    public func drive_permissions_create(
        path: Operations.Drive_permissions_create.Input.Path,
        query: Operations.Drive_permissions_create.Input.Query = .init(),
        headers: Operations.Drive_permissions_create.Input.Headers = .init(),
        body: Operations.Drive_permissions_create.Input.Body? = nil
    ) async throws -> Operations.Drive_permissions_create.Output {
        try await drive_permissions_create(Operations.Drive_permissions_create.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Gets a permission by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/get(drive.permissions.get)`.
    public func drive_permissions_get(
        path: Operations.Drive_permissions_get.Input.Path,
        query: Operations.Drive_permissions_get.Input.Query = .init(),
        headers: Operations.Drive_permissions_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_permissions_get.Output {
        try await drive_permissions_get(Operations.Drive_permissions_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Updates a permission with patch semantics. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/patch(drive.permissions.update)`.
    public func drive_permissions_update(
        path: Operations.Drive_permissions_update.Input.Path,
        query: Operations.Drive_permissions_update.Input.Query = .init(),
        headers: Operations.Drive_permissions_update.Input.Headers = .init(),
        body: Operations.Drive_permissions_update.Input.Body? = nil
    ) async throws -> Operations.Drive_permissions_update.Output {
        try await drive_permissions_update(Operations.Drive_permissions_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Deletes a permission. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/delete(drive.permissions.delete)`.
    public func drive_permissions_delete(
        path: Operations.Drive_permissions_delete.Input.Path,
        query: Operations.Drive_permissions_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_permissions_delete.Output {
        try await drive_permissions_delete(Operations.Drive_permissions_delete.Input(
            path: path,
            query: query
        ))
    }
    /// Lists a file's revisions.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/revisions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/get(drive.revisions.list)`.
    public func drive_revisions_list(
        path: Operations.Drive_revisions_list.Input.Path,
        query: Operations.Drive_revisions_list.Input.Query = .init(),
        headers: Operations.Drive_revisions_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_revisions_list.Output {
        try await drive_revisions_list(Operations.Drive_revisions_list.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Gets a revision's metadata or content by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/get(drive.revisions.get)`.
    public func drive_revisions_get(
        path: Operations.Drive_revisions_get.Input.Path,
        query: Operations.Drive_revisions_get.Input.Query = .init(),
        headers: Operations.Drive_revisions_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_revisions_get.Output {
        try await drive_revisions_get(Operations.Drive_revisions_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Updates a revision with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/patch(drive.revisions.update)`.
    public func drive_revisions_update(
        path: Operations.Drive_revisions_update.Input.Path,
        query: Operations.Drive_revisions_update.Input.Query = .init(),
        headers: Operations.Drive_revisions_update.Input.Headers = .init(),
        body: Operations.Drive_revisions_update.Input.Body? = nil
    ) async throws -> Operations.Drive_revisions_update.Output {
        try await drive_revisions_update(Operations.Drive_revisions_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Permanently deletes a file version. You can only delete revisions for files with binary content in Google Drive, like images or videos. Revisions for other files, like Google Docs or Sheets, and the last remaining file version can't be deleted.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/delete(drive.revisions.delete)`.
    public func drive_revisions_delete(
        path: Operations.Drive_revisions_delete.Input.Path,
        query: Operations.Drive_revisions_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_revisions_delete.Output {
        try await drive_revisions_delete(Operations.Drive_revisions_delete.Input(
            path: path,
            query: query
        ))
    }
    /// Subscribes to changes to a file.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/watch`.
    /// - Remark: Generated from `#/paths//files/{fileId}/watch/post(drive.files.watch)`.
    public func drive_files_watch(
        path: Operations.Drive_files_watch.Input.Path,
        query: Operations.Drive_files_watch.Input.Query = .init(),
        headers: Operations.Drive_files_watch.Input.Headers = .init(),
        body: Operations.Drive_files_watch.Input.Body? = nil
    ) async throws -> Operations.Drive_files_watch.Output {
        try await drive_files_watch(Operations.Drive_files_watch.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Deprecated: Use `drives.list` instead.
    ///
    /// - Remark: HTTP `GET /teamdrives`.
    /// - Remark: Generated from `#/paths//teamdrives/get(drive.teamdrives.list)`.
    public func drive_teamdrives_list(
        query: Operations.Drive_teamdrives_list.Input.Query = .init(),
        headers: Operations.Drive_teamdrives_list.Input.Headers = .init()
    ) async throws -> Operations.Drive_teamdrives_list.Output {
        try await drive_teamdrives_list(Operations.Drive_teamdrives_list.Input(
            query: query,
            headers: headers
        ))
    }
    /// Deprecated: Use `drives.create` instead.
    ///
    /// - Remark: HTTP `POST /teamdrives`.
    /// - Remark: Generated from `#/paths//teamdrives/post(drive.teamdrives.create)`.
    public func drive_teamdrives_create(
        query: Operations.Drive_teamdrives_create.Input.Query,
        headers: Operations.Drive_teamdrives_create.Input.Headers = .init(),
        body: Operations.Drive_teamdrives_create.Input.Body? = nil
    ) async throws -> Operations.Drive_teamdrives_create.Output {
        try await drive_teamdrives_create(Operations.Drive_teamdrives_create.Input(
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Deprecated: Use `drives.get` instead.
    ///
    /// - Remark: HTTP `GET /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/get(drive.teamdrives.get)`.
    public func drive_teamdrives_get(
        path: Operations.Drive_teamdrives_get.Input.Path,
        query: Operations.Drive_teamdrives_get.Input.Query = .init(),
        headers: Operations.Drive_teamdrives_get.Input.Headers = .init()
    ) async throws -> Operations.Drive_teamdrives_get.Output {
        try await drive_teamdrives_get(Operations.Drive_teamdrives_get.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Deprecated: Use `drives.update` instead.
    ///
    /// - Remark: HTTP `PATCH /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/patch(drive.teamdrives.update)`.
    public func drive_teamdrives_update(
        path: Operations.Drive_teamdrives_update.Input.Path,
        query: Operations.Drive_teamdrives_update.Input.Query = .init(),
        headers: Operations.Drive_teamdrives_update.Input.Headers = .init(),
        body: Operations.Drive_teamdrives_update.Input.Body? = nil
    ) async throws -> Operations.Drive_teamdrives_update.Output {
        try await drive_teamdrives_update(Operations.Drive_teamdrives_update.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Deprecated: Use `drives.delete` instead.
    ///
    /// - Remark: HTTP `DELETE /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/delete(drive.teamdrives.delete)`.
    public func drive_teamdrives_delete(
        path: Operations.Drive_teamdrives_delete.Input.Path,
        query: Operations.Drive_teamdrives_delete.Input.Query = .init()
    ) async throws -> Operations.Drive_teamdrives_delete.Output {
        try await drive_teamdrives_delete(Operations.Drive_teamdrives_delete.Input(
            path: path,
            query: query
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    public enum Server1 {
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://www.googleapis.com/drive/v3",
                variables: []
            )
        }
    }
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://www.googleapis.com/drive/v3",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// Information about the user, the user's Drive, and system capabilities.
        ///
        /// - Remark: Generated from `#/components/schemas/About`.
        public struct About: Codable, Hashable, Sendable {
            /// Whether the user has installed the requesting app.
            ///
            /// - Remark: Generated from `#/components/schemas/About/appInstalled`.
            public var appInstalled: Swift.Bool?
            /// Whether the user can create shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/About/canCreateDrives`.
            public var canCreateDrives: Swift.Bool?
            /// Deprecated: Use `canCreateDrives` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/About/canCreateTeamDrives`.
            @available(*, deprecated)
            public var canCreateTeamDrives: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/About/DriveThemesPayload`.
            public struct DriveThemesPayloadPayload: Codable, Hashable, Sendable {
                /// A link to this theme's background image.
                ///
                /// - Remark: Generated from `#/components/schemas/About/DriveThemesPayload/backgroundImageLink`.
                public var backgroundImageLink: Swift.String?
                /// The color of this theme as an RGB hex string.
                ///
                /// - Remark: Generated from `#/components/schemas/About/DriveThemesPayload/colorRgb`.
                public var colorRgb: Swift.String?
                /// The ID of the theme.
                ///
                /// - Remark: Generated from `#/components/schemas/About/DriveThemesPayload/id`.
                public var id: Swift.String?
                /// Creates a new `DriveThemesPayloadPayload`.
                ///
                /// - Parameters:
                ///   - backgroundImageLink: A link to this theme's background image.
                ///   - colorRgb: The color of this theme as an RGB hex string.
                ///   - id: The ID of the theme.
                public init(
                    backgroundImageLink: Swift.String? = nil,
                    colorRgb: Swift.String? = nil,
                    id: Swift.String? = nil
                ) {
                    self.backgroundImageLink = backgroundImageLink
                    self.colorRgb = colorRgb
                    self.id = id
                }
                public enum CodingKeys: String, CodingKey {
                    case backgroundImageLink
                    case colorRgb
                    case id
                }
            }
            /// A list of themes that are supported for shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/About/driveThemes`.
            public typealias DriveThemesPayload = [Components.Schemas.About.DriveThemesPayloadPayload]
            /// A list of themes that are supported for shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/About/driveThemes`.
            public var driveThemes: Components.Schemas.About.DriveThemesPayload?
            /// A map of source MIME type to possible targets for all supported exports.
            ///
            /// - Remark: Generated from `#/components/schemas/About/exportFormats`.
            public struct ExportFormatsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: [Swift.String]]
                /// Creates a new `ExportFormatsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: [Swift.String]] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A map of source MIME type to possible targets for all supported exports.
            ///
            /// - Remark: Generated from `#/components/schemas/About/exportFormats`.
            public var exportFormats: Components.Schemas.About.ExportFormatsPayload?
            /// The currently supported folder colors as RGB hex strings.
            ///
            /// - Remark: Generated from `#/components/schemas/About/folderColorPalette`.
            public var folderColorPalette: [Swift.String]?
            /// A map of source MIME type to possible targets for all supported imports.
            ///
            /// - Remark: Generated from `#/components/schemas/About/importFormats`.
            public struct ImportFormatsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: [Swift.String]]
                /// Creates a new `ImportFormatsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: [Swift.String]] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A map of source MIME type to possible targets for all supported imports.
            ///
            /// - Remark: Generated from `#/components/schemas/About/importFormats`.
            public var importFormats: Components.Schemas.About.ImportFormatsPayload?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#about"`.
            ///
            /// - Remark: Generated from `#/components/schemas/About/kind`.
            public var kind: Swift.String?
            /// A map of maximum import sizes by MIME type, in bytes.
            ///
            /// - Remark: Generated from `#/components/schemas/About/maxImportSizes`.
            public struct MaxImportSizesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `MaxImportSizesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A map of maximum import sizes by MIME type, in bytes.
            ///
            /// - Remark: Generated from `#/components/schemas/About/maxImportSizes`.
            public var maxImportSizes: Components.Schemas.About.MaxImportSizesPayload?
            /// The maximum upload size in bytes.
            ///
            /// - Remark: Generated from `#/components/schemas/About/maxUploadSize`.
            public var maxUploadSize: Swift.String?
            /// The user's storage quota limits and usage. All fields are measured in bytes.
            ///
            /// - Remark: Generated from `#/components/schemas/About/storageQuota`.
            public struct StorageQuotaPayload: Codable, Hashable, Sendable {
                /// The usage limit, if applicable. This will not be present if the user has unlimited storage.
                ///
                /// - Remark: Generated from `#/components/schemas/About/storageQuota/limit`.
                public var limit: Swift.String?
                /// The total usage across all services.
                ///
                /// - Remark: Generated from `#/components/schemas/About/storageQuota/usage`.
                public var usage: Swift.String?
                /// The usage by all files in Google Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/About/storageQuota/usageInDrive`.
                public var usageInDrive: Swift.String?
                /// The usage by trashed files in Google Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/About/storageQuota/usageInDriveTrash`.
                public var usageInDriveTrash: Swift.String?
                /// Creates a new `StorageQuotaPayload`.
                ///
                /// - Parameters:
                ///   - limit: The usage limit, if applicable. This will not be present if the user has unlimited storage.
                ///   - usage: The total usage across all services.
                ///   - usageInDrive: The usage by all files in Google Drive.
                ///   - usageInDriveTrash: The usage by trashed files in Google Drive.
                public init(
                    limit: Swift.String? = nil,
                    usage: Swift.String? = nil,
                    usageInDrive: Swift.String? = nil,
                    usageInDriveTrash: Swift.String? = nil
                ) {
                    self.limit = limit
                    self.usage = usage
                    self.usageInDrive = usageInDrive
                    self.usageInDriveTrash = usageInDriveTrash
                }
                public enum CodingKeys: String, CodingKey {
                    case limit
                    case usage
                    case usageInDrive
                    case usageInDriveTrash
                }
            }
            /// The user's storage quota limits and usage. All fields are measured in bytes.
            ///
            /// - Remark: Generated from `#/components/schemas/About/storageQuota`.
            public var storageQuota: Components.Schemas.About.StorageQuotaPayload?
            /// - Remark: Generated from `#/components/schemas/About/TeamDriveThemesPayload`.
            public struct TeamDriveThemesPayloadPayload: Codable, Hashable, Sendable {
                /// Deprecated: Use `driveThemes/backgroundImageLink` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/About/TeamDriveThemesPayload/backgroundImageLink`.
                @available(*, deprecated)
                public var backgroundImageLink: Swift.String?
                /// Deprecated: Use `driveThemes/colorRgb` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/About/TeamDriveThemesPayload/colorRgb`.
                @available(*, deprecated)
                public var colorRgb: Swift.String?
                /// Deprecated: Use `driveThemes/id` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/About/TeamDriveThemesPayload/id`.
                @available(*, deprecated)
                public var id: Swift.String?
                /// Creates a new `TeamDriveThemesPayloadPayload`.
                ///
                /// - Parameters:
                ///   - backgroundImageLink: Deprecated: Use `driveThemes/backgroundImageLink` instead.
                ///   - colorRgb: Deprecated: Use `driveThemes/colorRgb` instead.
                ///   - id: Deprecated: Use `driveThemes/id` instead.
                public init(
                    backgroundImageLink: Swift.String? = nil,
                    colorRgb: Swift.String? = nil,
                    id: Swift.String? = nil
                ) {
                    self.backgroundImageLink = backgroundImageLink
                    self.colorRgb = colorRgb
                    self.id = id
                }
                public enum CodingKeys: String, CodingKey {
                    case backgroundImageLink
                    case colorRgb
                    case id
                }
            }
            /// Deprecated: Use `driveThemes` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/About/teamDriveThemes`.
            public typealias TeamDriveThemesPayload = [Components.Schemas.About.TeamDriveThemesPayloadPayload]
            /// Deprecated: Use `driveThemes` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/About/teamDriveThemes`.
            @available(*, deprecated)
            public var teamDriveThemes: Components.Schemas.About.TeamDriveThemesPayload?
            /// - Remark: Generated from `#/components/schemas/About/user`.
            public var user: Components.Schemas.User?
            /// Creates a new `About`.
            ///
            /// - Parameters:
            ///   - appInstalled: Whether the user has installed the requesting app.
            ///   - canCreateDrives: Whether the user can create shared drives.
            ///   - canCreateTeamDrives: Deprecated: Use `canCreateDrives` instead.
            ///   - driveThemes: A list of themes that are supported for shared drives.
            ///   - exportFormats: A map of source MIME type to possible targets for all supported exports.
            ///   - folderColorPalette: The currently supported folder colors as RGB hex strings.
            ///   - importFormats: A map of source MIME type to possible targets for all supported imports.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#about"`.
            ///   - maxImportSizes: A map of maximum import sizes by MIME type, in bytes.
            ///   - maxUploadSize: The maximum upload size in bytes.
            ///   - storageQuota: The user's storage quota limits and usage. All fields are measured in bytes.
            ///   - teamDriveThemes: Deprecated: Use `driveThemes` instead.
            ///   - user:
            public init(
                appInstalled: Swift.Bool? = nil,
                canCreateDrives: Swift.Bool? = nil,
                canCreateTeamDrives: Swift.Bool? = nil,
                driveThemes: Components.Schemas.About.DriveThemesPayload? = nil,
                exportFormats: Components.Schemas.About.ExportFormatsPayload? = nil,
                folderColorPalette: [Swift.String]? = nil,
                importFormats: Components.Schemas.About.ImportFormatsPayload? = nil,
                kind: Swift.String? = nil,
                maxImportSizes: Components.Schemas.About.MaxImportSizesPayload? = nil,
                maxUploadSize: Swift.String? = nil,
                storageQuota: Components.Schemas.About.StorageQuotaPayload? = nil,
                teamDriveThemes: Components.Schemas.About.TeamDriveThemesPayload? = nil,
                user: Components.Schemas.User? = nil
            ) {
                self.appInstalled = appInstalled
                self.canCreateDrives = canCreateDrives
                self.canCreateTeamDrives = canCreateTeamDrives
                self.driveThemes = driveThemes
                self.exportFormats = exportFormats
                self.folderColorPalette = folderColorPalette
                self.importFormats = importFormats
                self.kind = kind
                self.maxImportSizes = maxImportSizes
                self.maxUploadSize = maxUploadSize
                self.storageQuota = storageQuota
                self.teamDriveThemes = teamDriveThemes
                self.user = user
            }
            public enum CodingKeys: String, CodingKey {
                case appInstalled
                case canCreateDrives
                case canCreateTeamDrives
                case driveThemes
                case exportFormats
                case folderColorPalette
                case importFormats
                case kind
                case maxImportSizes
                case maxUploadSize
                case storageQuota
                case teamDriveThemes
                case user
            }
        }
        /// The `apps` resource provides a list of apps that a user has installed, with information about each app's supported MIME types, file extensions, and other details. Some resource methods (such as `apps.get`) require an `appId`. Use the `apps.list` method to retrieve the ID for an installed application.
        ///
        /// - Remark: Generated from `#/components/schemas/App`.
        public struct App: Codable, Hashable, Sendable {
            /// Whether the app is authorized to access data on the user's Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/App/authorized`.
            public var authorized: Swift.Bool?
            /// The template URL to create a file with this app in a given folder. The template contains the {folderId} to be replaced by the folder ID house the new file.
            ///
            /// - Remark: Generated from `#/components/schemas/App/createInFolderTemplate`.
            public var createInFolderTemplate: Swift.String?
            /// The URL to create a file with this app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/createUrl`.
            public var createUrl: Swift.String?
            /// Whether the app has Drive-wide scope. An app with Drive-wide scope can access all files in the user's Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/App/hasDriveWideScope`.
            public var hasDriveWideScope: Swift.Bool?
            /// The various icons for the app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/icons`.
            public var icons: [Components.Schemas.AppIcons]?
            /// The ID of the app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/id`.
            public var id: Swift.String?
            /// Whether the app is installed.
            ///
            /// - Remark: Generated from `#/components/schemas/App/installed`.
            public var installed: Swift.Bool?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string "drive#app".
            ///
            /// - Remark: Generated from `#/components/schemas/App/kind`.
            public var kind: Swift.String?
            /// A long description of the app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/longDescription`.
            public var longDescription: Swift.String?
            /// The name of the app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/name`.
            public var name: Swift.String?
            /// The type of object this app creates such as a Chart. If empty, the app name should be used instead.
            ///
            /// - Remark: Generated from `#/components/schemas/App/objectType`.
            public var objectType: Swift.String?
            /// The template URL for opening files with this app. The template contains {ids} or {exportIds} to be replaced by the actual file IDs. For more information, see Open Files for the full documentation.
            ///
            /// - Remark: Generated from `#/components/schemas/App/openUrlTemplate`.
            public var openUrlTemplate: Swift.String?
            /// The list of primary file extensions.
            ///
            /// - Remark: Generated from `#/components/schemas/App/primaryFileExtensions`.
            public var primaryFileExtensions: [Swift.String]?
            /// The list of primary MIME types.
            ///
            /// - Remark: Generated from `#/components/schemas/App/primaryMimeTypes`.
            public var primaryMimeTypes: [Swift.String]?
            /// The ID of the product listing for this app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/productId`.
            public var productId: Swift.String?
            /// A link to the product listing for this app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/productUrl`.
            public var productUrl: Swift.String?
            /// The list of secondary file extensions.
            ///
            /// - Remark: Generated from `#/components/schemas/App/secondaryFileExtensions`.
            public var secondaryFileExtensions: [Swift.String]?
            /// The list of secondary MIME types.
            ///
            /// - Remark: Generated from `#/components/schemas/App/secondaryMimeTypes`.
            public var secondaryMimeTypes: [Swift.String]?
            /// A short description of the app.
            ///
            /// - Remark: Generated from `#/components/schemas/App/shortDescription`.
            public var shortDescription: Swift.String?
            /// Whether this app supports creating objects.
            ///
            /// - Remark: Generated from `#/components/schemas/App/supportsCreate`.
            public var supportsCreate: Swift.Bool?
            /// Whether this app supports importing from Google Docs.
            ///
            /// - Remark: Generated from `#/components/schemas/App/supportsImport`.
            public var supportsImport: Swift.Bool?
            /// Whether this app supports opening more than one file.
            ///
            /// - Remark: Generated from `#/components/schemas/App/supportsMultiOpen`.
            public var supportsMultiOpen: Swift.Bool?
            /// Whether this app supports creating files when offline.
            ///
            /// - Remark: Generated from `#/components/schemas/App/supportsOfflineCreate`.
            public var supportsOfflineCreate: Swift.Bool?
            /// Whether the app is selected as the default handler for the types it supports.
            ///
            /// - Remark: Generated from `#/components/schemas/App/useByDefault`.
            public var useByDefault: Swift.Bool?
            /// Creates a new `App`.
            ///
            /// - Parameters:
            ///   - authorized: Whether the app is authorized to access data on the user's Drive.
            ///   - createInFolderTemplate: The template URL to create a file with this app in a given folder. The template contains the {folderId} to be replaced by the folder ID house the new file.
            ///   - createUrl: The URL to create a file with this app.
            ///   - hasDriveWideScope: Whether the app has Drive-wide scope. An app with Drive-wide scope can access all files in the user's Drive.
            ///   - icons: The various icons for the app.
            ///   - id: The ID of the app.
            ///   - installed: Whether the app is installed.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string "drive#app".
            ///   - longDescription: A long description of the app.
            ///   - name: The name of the app.
            ///   - objectType: The type of object this app creates such as a Chart. If empty, the app name should be used instead.
            ///   - openUrlTemplate: The template URL for opening files with this app. The template contains {ids} or {exportIds} to be replaced by the actual file IDs. For more information, see Open Files for the full documentation.
            ///   - primaryFileExtensions: The list of primary file extensions.
            ///   - primaryMimeTypes: The list of primary MIME types.
            ///   - productId: The ID of the product listing for this app.
            ///   - productUrl: A link to the product listing for this app.
            ///   - secondaryFileExtensions: The list of secondary file extensions.
            ///   - secondaryMimeTypes: The list of secondary MIME types.
            ///   - shortDescription: A short description of the app.
            ///   - supportsCreate: Whether this app supports creating objects.
            ///   - supportsImport: Whether this app supports importing from Google Docs.
            ///   - supportsMultiOpen: Whether this app supports opening more than one file.
            ///   - supportsOfflineCreate: Whether this app supports creating files when offline.
            ///   - useByDefault: Whether the app is selected as the default handler for the types it supports.
            public init(
                authorized: Swift.Bool? = nil,
                createInFolderTemplate: Swift.String? = nil,
                createUrl: Swift.String? = nil,
                hasDriveWideScope: Swift.Bool? = nil,
                icons: [Components.Schemas.AppIcons]? = nil,
                id: Swift.String? = nil,
                installed: Swift.Bool? = nil,
                kind: Swift.String? = nil,
                longDescription: Swift.String? = nil,
                name: Swift.String? = nil,
                objectType: Swift.String? = nil,
                openUrlTemplate: Swift.String? = nil,
                primaryFileExtensions: [Swift.String]? = nil,
                primaryMimeTypes: [Swift.String]? = nil,
                productId: Swift.String? = nil,
                productUrl: Swift.String? = nil,
                secondaryFileExtensions: [Swift.String]? = nil,
                secondaryMimeTypes: [Swift.String]? = nil,
                shortDescription: Swift.String? = nil,
                supportsCreate: Swift.Bool? = nil,
                supportsImport: Swift.Bool? = nil,
                supportsMultiOpen: Swift.Bool? = nil,
                supportsOfflineCreate: Swift.Bool? = nil,
                useByDefault: Swift.Bool? = nil
            ) {
                self.authorized = authorized
                self.createInFolderTemplate = createInFolderTemplate
                self.createUrl = createUrl
                self.hasDriveWideScope = hasDriveWideScope
                self.icons = icons
                self.id = id
                self.installed = installed
                self.kind = kind
                self.longDescription = longDescription
                self.name = name
                self.objectType = objectType
                self.openUrlTemplate = openUrlTemplate
                self.primaryFileExtensions = primaryFileExtensions
                self.primaryMimeTypes = primaryMimeTypes
                self.productId = productId
                self.productUrl = productUrl
                self.secondaryFileExtensions = secondaryFileExtensions
                self.secondaryMimeTypes = secondaryMimeTypes
                self.shortDescription = shortDescription
                self.supportsCreate = supportsCreate
                self.supportsImport = supportsImport
                self.supportsMultiOpen = supportsMultiOpen
                self.supportsOfflineCreate = supportsOfflineCreate
                self.useByDefault = useByDefault
            }
            public enum CodingKeys: String, CodingKey {
                case authorized
                case createInFolderTemplate
                case createUrl
                case hasDriveWideScope
                case icons
                case id
                case installed
                case kind
                case longDescription
                case name
                case objectType
                case openUrlTemplate
                case primaryFileExtensions
                case primaryMimeTypes
                case productId
                case productUrl
                case secondaryFileExtensions
                case secondaryMimeTypes
                case shortDescription
                case supportsCreate
                case supportsImport
                case supportsMultiOpen
                case supportsOfflineCreate
                case useByDefault
            }
        }
        /// - Remark: Generated from `#/components/schemas/AppIcons`.
        public struct AppIcons: Codable, Hashable, Sendable {
            /// Category of the icon. Allowed values are: * `application` - The icon for the application. * `document` - The icon for a file associated with the app. * `documentShared` - The icon for a shared file associated with the app.
            ///
            /// - Remark: Generated from `#/components/schemas/AppIcons/category`.
            public var category: Swift.String?
            /// URL for the icon.
            ///
            /// - Remark: Generated from `#/components/schemas/AppIcons/iconUrl`.
            public var iconUrl: Swift.String?
            /// Size of the icon. Represented as the maximum of the width and height.
            ///
            /// - Remark: Generated from `#/components/schemas/AppIcons/size`.
            public var size: Swift.Int32?
            /// Creates a new `AppIcons`.
            ///
            /// - Parameters:
            ///   - category: Category of the icon. Allowed values are: * `application` - The icon for the application. * `document` - The icon for a file associated with the app. * `documentShared` - The icon for a shared file associated with the app.
            ///   - iconUrl: URL for the icon.
            ///   - size: Size of the icon. Represented as the maximum of the width and height.
            public init(
                category: Swift.String? = nil,
                iconUrl: Swift.String? = nil,
                size: Swift.Int32? = nil
            ) {
                self.category = category
                self.iconUrl = iconUrl
                self.size = size
            }
            public enum CodingKeys: String, CodingKey {
                case category
                case iconUrl
                case size
            }
        }
        /// A list of third-party applications which the user has installed or given access to Google Drive.
        ///
        /// - Remark: Generated from `#/components/schemas/AppList`.
        public struct AppList: Codable, Hashable, Sendable {
            /// The list of app IDs that the user has specified to use by default. The list is in reverse-priority order (lowest to highest).
            ///
            /// - Remark: Generated from `#/components/schemas/AppList/defaultAppIds`.
            public var defaultAppIds: [Swift.String]?
            /// The list of apps.
            ///
            /// - Remark: Generated from `#/components/schemas/AppList/items`.
            public var items: [Components.Schemas.App]?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string "drive#appList".
            ///
            /// - Remark: Generated from `#/components/schemas/AppList/kind`.
            public var kind: Swift.String?
            /// A link back to this list.
            ///
            /// - Remark: Generated from `#/components/schemas/AppList/selfLink`.
            public var selfLink: Swift.String?
            /// Creates a new `AppList`.
            ///
            /// - Parameters:
            ///   - defaultAppIds: The list of app IDs that the user has specified to use by default. The list is in reverse-priority order (lowest to highest).
            ///   - items: The list of apps.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string "drive#appList".
            ///   - selfLink: A link back to this list.
            public init(
                defaultAppIds: [Swift.String]? = nil,
                items: [Components.Schemas.App]? = nil,
                kind: Swift.String? = nil,
                selfLink: Swift.String? = nil
            ) {
                self.defaultAppIds = defaultAppIds
                self.items = items
                self.kind = kind
                self.selfLink = selfLink
            }
            public enum CodingKeys: String, CodingKey {
                case defaultAppIds
                case items
                case kind
                case selfLink
            }
        }
        /// A change to a file or shared drive.
        ///
        /// - Remark: Generated from `#/components/schemas/Change`.
        public struct Change: Codable, Hashable, Sendable {
            /// The type of the change. Possible values are `file` and `drive`.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/changeType`.
            public var changeType: Swift.String?
            /// - Remark: Generated from `#/components/schemas/Change/drive`.
            public var drive: Components.Schemas.Drive?
            /// The ID of the shared drive associated with this change.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/driveId`.
            public var driveId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/Change/file`.
            public var file: Components.Schemas.File?
            /// The ID of the file which has changed.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/fileId`.
            public var fileId: Swift.String?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#change"`.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/kind`.
            public var kind: Swift.String?
            /// Whether the file or shared drive has been removed from this list of changes, for example by deletion or loss of access.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/removed`.
            public var removed: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/Change/teamDrive`.
            public var teamDrive: Components.Schemas.TeamDrive?
            /// Deprecated: Use `driveId` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/teamDriveId`.
            @available(*, deprecated)
            public var teamDriveId: Swift.String?
            /// The time of this change (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Change/time`.
            public var time: Foundation.Date?
            /// Deprecated: Use `changeType` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/Change/type`.
            @available(*, deprecated)
            public var _type: Swift.String?
            /// Creates a new `Change`.
            ///
            /// - Parameters:
            ///   - changeType: The type of the change. Possible values are `file` and `drive`.
            ///   - drive:
            ///   - driveId: The ID of the shared drive associated with this change.
            ///   - file:
            ///   - fileId: The ID of the file which has changed.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#change"`.
            ///   - removed: Whether the file or shared drive has been removed from this list of changes, for example by deletion or loss of access.
            ///   - teamDrive:
            ///   - teamDriveId: Deprecated: Use `driveId` instead.
            ///   - time: The time of this change (RFC 3339 date-time).
            ///   - _type: Deprecated: Use `changeType` instead.
            public init(
                changeType: Swift.String? = nil,
                drive: Components.Schemas.Drive? = nil,
                driveId: Swift.String? = nil,
                file: Components.Schemas.File? = nil,
                fileId: Swift.String? = nil,
                kind: Swift.String? = nil,
                removed: Swift.Bool? = nil,
                teamDrive: Components.Schemas.TeamDrive? = nil,
                teamDriveId: Swift.String? = nil,
                time: Foundation.Date? = nil,
                _type: Swift.String? = nil
            ) {
                self.changeType = changeType
                self.drive = drive
                self.driveId = driveId
                self.file = file
                self.fileId = fileId
                self.kind = kind
                self.removed = removed
                self.teamDrive = teamDrive
                self.teamDriveId = teamDriveId
                self.time = time
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case changeType
                case drive
                case driveId
                case file
                case fileId
                case kind
                case removed
                case teamDrive
                case teamDriveId
                case time
                case _type = "type"
            }
        }
        /// A list of changes for a user.
        ///
        /// - Remark: Generated from `#/components/schemas/ChangeList`.
        public struct ChangeList: Codable, Hashable, Sendable {
            /// The list of changes. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/ChangeList/changes`.
            public var changes: [Components.Schemas.Change]?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#changeList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/ChangeList/kind`.
            public var kind: Swift.String?
            /// The starting page token for future changes. This will be present only if the end of the current changes list has been reached. The page token doesn't expire.
            ///
            /// - Remark: Generated from `#/components/schemas/ChangeList/newStartPageToken`.
            public var newStartPageToken: Swift.String?
            /// The page token for the next page of changes. This will be absent if the end of the changes list has been reached. The page token doesn't expire.
            ///
            /// - Remark: Generated from `#/components/schemas/ChangeList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// Creates a new `ChangeList`.
            ///
            /// - Parameters:
            ///   - changes: The list of changes. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#changeList"`.
            ///   - newStartPageToken: The starting page token for future changes. This will be present only if the end of the current changes list has been reached. The page token doesn't expire.
            ///   - nextPageToken: The page token for the next page of changes. This will be absent if the end of the changes list has been reached. The page token doesn't expire.
            public init(
                changes: [Components.Schemas.Change]? = nil,
                kind: Swift.String? = nil,
                newStartPageToken: Swift.String? = nil,
                nextPageToken: Swift.String? = nil
            ) {
                self.changes = changes
                self.kind = kind
                self.newStartPageToken = newStartPageToken
                self.nextPageToken = nextPageToken
            }
            public enum CodingKeys: String, CodingKey {
                case changes
                case kind
                case newStartPageToken
                case nextPageToken
            }
        }
        /// A notification channel used to watch for resource changes.
        ///
        /// - Remark: Generated from `#/components/schemas/Channel`.
        public struct Channel: Codable, Hashable, Sendable {
            /// The address where notifications are delivered for this channel.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/address`.
            public var address: Swift.String?
            /// Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/expiration`.
            public var expiration: Swift.String?
            /// A UUID or similar unique string that identifies this channel.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/id`.
            public var id: Swift.String?
            /// Identifies this as a notification channel used to watch for changes to a resource, which is `api#channel`.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/kind`.
            public var kind: Swift.String?
            /// Additional parameters controlling delivery channel behavior. Optional.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/params`.
            public struct ParamsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `ParamsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// Additional parameters controlling delivery channel behavior. Optional.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/params`.
            public var params: Components.Schemas.Channel.ParamsPayload?
            /// A Boolean value to indicate whether payload is wanted. Optional.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/payload`.
            public var payload: Swift.Bool?
            /// An opaque ID that identifies the resource being watched on this channel. Stable across different API versions.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/resourceId`.
            public var resourceId: Swift.String?
            /// A version-specific identifier for the watched resource.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/resourceUri`.
            public var resourceUri: Swift.String?
            /// An arbitrary string delivered to the target address with each notification delivered over this channel. Optional.
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/token`.
            public var token: Swift.String?
            /// The type of delivery mechanism used for this channel. Valid values are "web_hook" or "webhook".
            ///
            /// - Remark: Generated from `#/components/schemas/Channel/type`.
            public var _type: Swift.String?
            /// Creates a new `Channel`.
            ///
            /// - Parameters:
            ///   - address: The address where notifications are delivered for this channel.
            ///   - expiration: Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.
            ///   - id: A UUID or similar unique string that identifies this channel.
            ///   - kind: Identifies this as a notification channel used to watch for changes to a resource, which is `api#channel`.
            ///   - params: Additional parameters controlling delivery channel behavior. Optional.
            ///   - payload: A Boolean value to indicate whether payload is wanted. Optional.
            ///   - resourceId: An opaque ID that identifies the resource being watched on this channel. Stable across different API versions.
            ///   - resourceUri: A version-specific identifier for the watched resource.
            ///   - token: An arbitrary string delivered to the target address with each notification delivered over this channel. Optional.
            ///   - _type: The type of delivery mechanism used for this channel. Valid values are "web_hook" or "webhook".
            public init(
                address: Swift.String? = nil,
                expiration: Swift.String? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                params: Components.Schemas.Channel.ParamsPayload? = nil,
                payload: Swift.Bool? = nil,
                resourceId: Swift.String? = nil,
                resourceUri: Swift.String? = nil,
                token: Swift.String? = nil,
                _type: Swift.String? = nil
            ) {
                self.address = address
                self.expiration = expiration
                self.id = id
                self.kind = kind
                self.params = params
                self.payload = payload
                self.resourceId = resourceId
                self.resourceUri = resourceUri
                self.token = token
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case address
                case expiration
                case id
                case kind
                case params
                case payload
                case resourceId
                case resourceUri
                case token
                case _type = "type"
            }
        }
        /// A comment on a file. Some resource methods (such as `comments.update`) require a `commentId`. Use the `comments.list` method to retrieve the ID for a comment in a file.
        ///
        /// - Remark: Generated from `#/components/schemas/Comment`.
        public struct Comment: Codable, Hashable, Sendable {
            /// A region of the document represented as a JSON string. For details on defining anchor properties, refer to [Manage comments and replies](https://developers.google.com/drive/api/v3/manage-comments).
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/anchor`.
            public var anchor: Swift.String?
            /// - Remark: Generated from `#/components/schemas/Comment/author`.
            public var author: Components.Schemas.User?
            /// The plain text content of the comment. This field is used for setting the content, while `htmlContent` should be displayed.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/content`.
            public var content: Swift.String?
            /// The time at which the comment was created (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/createdTime`.
            public var createdTime: Foundation.Date?
            /// Output only. Whether the comment has been deleted. A deleted comment has no content.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/deleted`.
            public var deleted: Swift.Bool?
            /// Output only. The content of the comment with HTML formatting.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/htmlContent`.
            public var htmlContent: Swift.String?
            /// Output only. The ID of the comment.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/id`.
            public var id: Swift.String?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#comment"`.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/kind`.
            public var kind: Swift.String?
            /// The last time the comment or any of its replies was modified (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/modifiedTime`.
            public var modifiedTime: Foundation.Date?
            /// The file content to which the comment refers, typically within the anchor region. For a text file, for example, this would be the text at the location of the comment.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/quotedFileContent`.
            public struct QuotedFileContentPayload: Codable, Hashable, Sendable {
                /// The MIME type of the quoted content.
                ///
                /// - Remark: Generated from `#/components/schemas/Comment/quotedFileContent/mimeType`.
                public var mimeType: Swift.String?
                /// The quoted content itself. This is interpreted as plain text if set through the API.
                ///
                /// - Remark: Generated from `#/components/schemas/Comment/quotedFileContent/value`.
                public var value: Swift.String?
                /// Creates a new `QuotedFileContentPayload`.
                ///
                /// - Parameters:
                ///   - mimeType: The MIME type of the quoted content.
                ///   - value: The quoted content itself. This is interpreted as plain text if set through the API.
                public init(
                    mimeType: Swift.String? = nil,
                    value: Swift.String? = nil
                ) {
                    self.mimeType = mimeType
                    self.value = value
                }
                public enum CodingKeys: String, CodingKey {
                    case mimeType
                    case value
                }
            }
            /// The file content to which the comment refers, typically within the anchor region. For a text file, for example, this would be the text at the location of the comment.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/quotedFileContent`.
            public var quotedFileContent: Components.Schemas.Comment.QuotedFileContentPayload?
            /// Output only. The full list of replies to the comment in chronological order.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/replies`.
            public var replies: [Components.Schemas.Reply]?
            /// Output only. Whether the comment has been resolved by one of its replies.
            ///
            /// - Remark: Generated from `#/components/schemas/Comment/resolved`.
            public var resolved: Swift.Bool?
            /// Creates a new `Comment`.
            ///
            /// - Parameters:
            ///   - anchor: A region of the document represented as a JSON string. For details on defining anchor properties, refer to [Manage comments and replies](https://developers.google.com/drive/api/v3/manage-comments).
            ///   - author:
            ///   - content: The plain text content of the comment. This field is used for setting the content, while `htmlContent` should be displayed.
            ///   - createdTime: The time at which the comment was created (RFC 3339 date-time).
            ///   - deleted: Output only. Whether the comment has been deleted. A deleted comment has no content.
            ///   - htmlContent: Output only. The content of the comment with HTML formatting.
            ///   - id: Output only. The ID of the comment.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#comment"`.
            ///   - modifiedTime: The last time the comment or any of its replies was modified (RFC 3339 date-time).
            ///   - quotedFileContent: The file content to which the comment refers, typically within the anchor region. For a text file, for example, this would be the text at the location of the comment.
            ///   - replies: Output only. The full list of replies to the comment in chronological order.
            ///   - resolved: Output only. Whether the comment has been resolved by one of its replies.
            public init(
                anchor: Swift.String? = nil,
                author: Components.Schemas.User? = nil,
                content: Swift.String? = nil,
                createdTime: Foundation.Date? = nil,
                deleted: Swift.Bool? = nil,
                htmlContent: Swift.String? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                modifiedTime: Foundation.Date? = nil,
                quotedFileContent: Components.Schemas.Comment.QuotedFileContentPayload? = nil,
                replies: [Components.Schemas.Reply]? = nil,
                resolved: Swift.Bool? = nil
            ) {
                self.anchor = anchor
                self.author = author
                self.content = content
                self.createdTime = createdTime
                self.deleted = deleted
                self.htmlContent = htmlContent
                self.id = id
                self.kind = kind
                self.modifiedTime = modifiedTime
                self.quotedFileContent = quotedFileContent
                self.replies = replies
                self.resolved = resolved
            }
            public enum CodingKeys: String, CodingKey {
                case anchor
                case author
                case content
                case createdTime
                case deleted
                case htmlContent
                case id
                case kind
                case modifiedTime
                case quotedFileContent
                case replies
                case resolved
            }
        }
        /// A list of comments on a file.
        ///
        /// - Remark: Generated from `#/components/schemas/CommentList`.
        public struct CommentList: Codable, Hashable, Sendable {
            /// The list of comments. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/CommentList/comments`.
            public var comments: [Components.Schemas.Comment]?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#commentList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/CommentList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of comments. This will be absent if the end of the comments list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/CommentList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// Creates a new `CommentList`.
            ///
            /// - Parameters:
            ///   - comments: The list of comments. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#commentList"`.
            ///   - nextPageToken: The page token for the next page of comments. This will be absent if the end of the comments list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            public init(
                comments: [Components.Schemas.Comment]? = nil,
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil
            ) {
                self.comments = comments
                self.kind = kind
                self.nextPageToken = nextPageToken
            }
            public enum CodingKeys: String, CodingKey {
                case comments
                case kind
                case nextPageToken
            }
        }
        /// A restriction for accessing the content of the file.
        ///
        /// - Remark: Generated from `#/components/schemas/ContentRestriction`.
        public struct ContentRestriction: Codable, Hashable, Sendable {
            /// Whether the content restriction can only be modified or removed by a user who owns the file. For files in shared drives, any user with `organizer` capabilities can modify or remove this content restriction.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/ownerRestricted`.
            public var ownerRestricted: Swift.Bool?
            /// Whether the content of the file is read-only. If a file is read-only, a new revision of the file may not be added, comments may not be added or modified, and the title of the file may not be modified.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/readOnly`.
            public var readOnly: Swift.Bool?
            /// Reason for why the content of the file is restricted. This is only mutable on requests that also set `readOnly=true`.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/reason`.
            public var reason: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/restrictingUser`.
            public var restrictingUser: Components.Schemas.User?
            /// The time at which the content restriction was set (formatted RFC 3339 timestamp). Only populated if readOnly is true.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/restrictionTime`.
            public var restrictionTime: Foundation.Date?
            /// Output only. Whether the content restriction was applied by the system, for example due to an esignature. Users cannot modify or remove system restricted content restrictions.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/systemRestricted`.
            public var systemRestricted: Swift.Bool?
            /// Output only. The type of the content restriction. Currently the only possible value is `globalContentRestriction`.
            ///
            /// - Remark: Generated from `#/components/schemas/ContentRestriction/type`.
            public var _type: Swift.String?
            /// Creates a new `ContentRestriction`.
            ///
            /// - Parameters:
            ///   - ownerRestricted: Whether the content restriction can only be modified or removed by a user who owns the file. For files in shared drives, any user with `organizer` capabilities can modify or remove this content restriction.
            ///   - readOnly: Whether the content of the file is read-only. If a file is read-only, a new revision of the file may not be added, comments may not be added or modified, and the title of the file may not be modified.
            ///   - reason: Reason for why the content of the file is restricted. This is only mutable on requests that also set `readOnly=true`.
            ///   - restrictingUser:
            ///   - restrictionTime: The time at which the content restriction was set (formatted RFC 3339 timestamp). Only populated if readOnly is true.
            ///   - systemRestricted: Output only. Whether the content restriction was applied by the system, for example due to an esignature. Users cannot modify or remove system restricted content restrictions.
            ///   - _type: Output only. The type of the content restriction. Currently the only possible value is `globalContentRestriction`.
            public init(
                ownerRestricted: Swift.Bool? = nil,
                readOnly: Swift.Bool? = nil,
                reason: Swift.String? = nil,
                restrictingUser: Components.Schemas.User? = nil,
                restrictionTime: Foundation.Date? = nil,
                systemRestricted: Swift.Bool? = nil,
                _type: Swift.String? = nil
            ) {
                self.ownerRestricted = ownerRestricted
                self.readOnly = readOnly
                self.reason = reason
                self.restrictingUser = restrictingUser
                self.restrictionTime = restrictionTime
                self.systemRestricted = systemRestricted
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case ownerRestricted
                case readOnly
                case reason
                case restrictingUser
                case restrictionTime
                case systemRestricted
                case _type = "type"
            }
        }
        /// Representation of a shared drive. Some resource methods (such as `drives.update`) require a `driveId`. Use the `drives.list` method to retrieve the ID for a shared drive.
        ///
        /// - Remark: Generated from `#/components/schemas/Drive`.
        public struct Drive: Codable, Hashable, Sendable {
            /// An image file and cropping parameters from which a background image for this shared drive is set. This is a write only field; it can only be set on `drive.drives.update` requests that don't set `themeId`. When specified, all fields of the `backgroundImageFile` must be set.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageFile`.
            public struct BackgroundImageFilePayload: Codable, Hashable, Sendable {
                /// The ID of an image file in Google Drive to use for the background image.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageFile/id`.
                public var id: Swift.String?
                /// The width of the cropped image in the closed range of 0 to 1. This value represents the width of the cropped image divided by the width of the entire image. The height is computed by applying a width to height aspect ratio of 80 to 9. The resulting image must be at least 1280 pixels wide and 144 pixels high.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageFile/width`.
                public var width: Swift.Float?
                /// The X coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the horizontal distance from the left side of the entire image to the left side of the cropping area divided by the width of the entire image.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageFile/xCoordinate`.
                public var xCoordinate: Swift.Float?
                /// The Y coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the vertical distance from the top side of the entire image to the top side of the cropping area divided by the height of the entire image.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageFile/yCoordinate`.
                public var yCoordinate: Swift.Float?
                /// Creates a new `BackgroundImageFilePayload`.
                ///
                /// - Parameters:
                ///   - id: The ID of an image file in Google Drive to use for the background image.
                ///   - width: The width of the cropped image in the closed range of 0 to 1. This value represents the width of the cropped image divided by the width of the entire image. The height is computed by applying a width to height aspect ratio of 80 to 9. The resulting image must be at least 1280 pixels wide and 144 pixels high.
                ///   - xCoordinate: The X coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the horizontal distance from the left side of the entire image to the left side of the cropping area divided by the width of the entire image.
                ///   - yCoordinate: The Y coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the vertical distance from the top side of the entire image to the top side of the cropping area divided by the height of the entire image.
                public init(
                    id: Swift.String? = nil,
                    width: Swift.Float? = nil,
                    xCoordinate: Swift.Float? = nil,
                    yCoordinate: Swift.Float? = nil
                ) {
                    self.id = id
                    self.width = width
                    self.xCoordinate = xCoordinate
                    self.yCoordinate = yCoordinate
                }
                public enum CodingKeys: String, CodingKey {
                    case id
                    case width
                    case xCoordinate
                    case yCoordinate
                }
            }
            /// An image file and cropping parameters from which a background image for this shared drive is set. This is a write only field; it can only be set on `drive.drives.update` requests that don't set `themeId`. When specified, all fields of the `backgroundImageFile` must be set.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageFile`.
            public var backgroundImageFile: Components.Schemas.Drive.BackgroundImageFilePayload?
            /// Output only. A short-lived link to this shared drive's background image.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/backgroundImageLink`.
            public var backgroundImageLink: Swift.String?
            /// Output only. Capabilities the current user has on this shared drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/capabilities`.
            public struct CapabilitiesPayload: Codable, Hashable, Sendable {
                /// Output only. Whether the current user can add children to folders in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canAddChildren`.
                public var canAddChildren: Swift.Bool?
                /// Output only. Whether the current user can change the `copyRequiresWriterPermission` restriction of this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canChangeCopyRequiresWriterPermissionRestriction`.
                public var canChangeCopyRequiresWriterPermissionRestriction: Swift.Bool?
                /// Output only. Whether the current user can change the `domainUsersOnly` restriction of this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canChangeDomainUsersOnlyRestriction`.
                public var canChangeDomainUsersOnlyRestriction: Swift.Bool?
                /// Output only. Whether the current user can change the background of this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canChangeDriveBackground`.
                public var canChangeDriveBackground: Swift.Bool?
                /// Output only. Whether the current user can change the `driveMembersOnly` restriction of this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canChangeDriveMembersOnlyRestriction`.
                public var canChangeDriveMembersOnlyRestriction: Swift.Bool?
                /// Output only. Whether the current user can change the `sharingFoldersRequiresOrganizerPermission` restriction of this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canChangeSharingFoldersRequiresOrganizerPermissionRestriction`.
                public var canChangeSharingFoldersRequiresOrganizerPermissionRestriction: Swift.Bool?
                /// Output only. Whether the current user can comment on files in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canComment`.
                public var canComment: Swift.Bool?
                /// Output only. Whether the current user can copy files in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canCopy`.
                public var canCopy: Swift.Bool?
                /// Output only. Whether the current user can delete children from folders in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canDeleteChildren`.
                public var canDeleteChildren: Swift.Bool?
                /// Output only. Whether the current user can delete this shared drive. Attempting to delete the shared drive may still fail if there are untrashed items inside the shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canDeleteDrive`.
                public var canDeleteDrive: Swift.Bool?
                /// Output only. Whether the current user can download files in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canDownload`.
                public var canDownload: Swift.Bool?
                /// Output only. Whether the current user can edit files in this shared drive
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canEdit`.
                public var canEdit: Swift.Bool?
                /// Output only. Whether the current user can list the children of folders in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canListChildren`.
                public var canListChildren: Swift.Bool?
                /// Output only. Whether the current user can add members to this shared drive or remove them or change their role.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canManageMembers`.
                public var canManageMembers: Swift.Bool?
                /// Output only. Whether the current user can read the revisions resource of files in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canReadRevisions`.
                public var canReadRevisions: Swift.Bool?
                /// Output only. Whether the current user can rename files or folders in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canRename`.
                public var canRename: Swift.Bool?
                /// Output only. Whether the current user can rename this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canRenameDrive`.
                public var canRenameDrive: Swift.Bool?
                /// Output only. Whether the current user can reset the shared drive restrictions to defaults.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canResetDriveRestrictions`.
                public var canResetDriveRestrictions: Swift.Bool?
                /// Output only. Whether the current user can share files or folders in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canShare`.
                public var canShare: Swift.Bool?
                /// Output only. Whether the current user can trash children from folders in this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/capabilities/canTrashChildren`.
                public var canTrashChildren: Swift.Bool?
                /// Creates a new `CapabilitiesPayload`.
                ///
                /// - Parameters:
                ///   - canAddChildren: Output only. Whether the current user can add children to folders in this shared drive.
                ///   - canChangeCopyRequiresWriterPermissionRestriction: Output only. Whether the current user can change the `copyRequiresWriterPermission` restriction of this shared drive.
                ///   - canChangeDomainUsersOnlyRestriction: Output only. Whether the current user can change the `domainUsersOnly` restriction of this shared drive.
                ///   - canChangeDriveBackground: Output only. Whether the current user can change the background of this shared drive.
                ///   - canChangeDriveMembersOnlyRestriction: Output only. Whether the current user can change the `driveMembersOnly` restriction of this shared drive.
                ///   - canChangeSharingFoldersRequiresOrganizerPermissionRestriction: Output only. Whether the current user can change the `sharingFoldersRequiresOrganizerPermission` restriction of this shared drive.
                ///   - canComment: Output only. Whether the current user can comment on files in this shared drive.
                ///   - canCopy: Output only. Whether the current user can copy files in this shared drive.
                ///   - canDeleteChildren: Output only. Whether the current user can delete children from folders in this shared drive.
                ///   - canDeleteDrive: Output only. Whether the current user can delete this shared drive. Attempting to delete the shared drive may still fail if there are untrashed items inside the shared drive.
                ///   - canDownload: Output only. Whether the current user can download files in this shared drive.
                ///   - canEdit: Output only. Whether the current user can edit files in this shared drive
                ///   - canListChildren: Output only. Whether the current user can list the children of folders in this shared drive.
                ///   - canManageMembers: Output only. Whether the current user can add members to this shared drive or remove them or change their role.
                ///   - canReadRevisions: Output only. Whether the current user can read the revisions resource of files in this shared drive.
                ///   - canRename: Output only. Whether the current user can rename files or folders in this shared drive.
                ///   - canRenameDrive: Output only. Whether the current user can rename this shared drive.
                ///   - canResetDriveRestrictions: Output only. Whether the current user can reset the shared drive restrictions to defaults.
                ///   - canShare: Output only. Whether the current user can share files or folders in this shared drive.
                ///   - canTrashChildren: Output only. Whether the current user can trash children from folders in this shared drive.
                public init(
                    canAddChildren: Swift.Bool? = nil,
                    canChangeCopyRequiresWriterPermissionRestriction: Swift.Bool? = nil,
                    canChangeDomainUsersOnlyRestriction: Swift.Bool? = nil,
                    canChangeDriveBackground: Swift.Bool? = nil,
                    canChangeDriveMembersOnlyRestriction: Swift.Bool? = nil,
                    canChangeSharingFoldersRequiresOrganizerPermissionRestriction: Swift.Bool? = nil,
                    canComment: Swift.Bool? = nil,
                    canCopy: Swift.Bool? = nil,
                    canDeleteChildren: Swift.Bool? = nil,
                    canDeleteDrive: Swift.Bool? = nil,
                    canDownload: Swift.Bool? = nil,
                    canEdit: Swift.Bool? = nil,
                    canListChildren: Swift.Bool? = nil,
                    canManageMembers: Swift.Bool? = nil,
                    canReadRevisions: Swift.Bool? = nil,
                    canRename: Swift.Bool? = nil,
                    canRenameDrive: Swift.Bool? = nil,
                    canResetDriveRestrictions: Swift.Bool? = nil,
                    canShare: Swift.Bool? = nil,
                    canTrashChildren: Swift.Bool? = nil
                ) {
                    self.canAddChildren = canAddChildren
                    self.canChangeCopyRequiresWriterPermissionRestriction = canChangeCopyRequiresWriterPermissionRestriction
                    self.canChangeDomainUsersOnlyRestriction = canChangeDomainUsersOnlyRestriction
                    self.canChangeDriveBackground = canChangeDriveBackground
                    self.canChangeDriveMembersOnlyRestriction = canChangeDriveMembersOnlyRestriction
                    self.canChangeSharingFoldersRequiresOrganizerPermissionRestriction = canChangeSharingFoldersRequiresOrganizerPermissionRestriction
                    self.canComment = canComment
                    self.canCopy = canCopy
                    self.canDeleteChildren = canDeleteChildren
                    self.canDeleteDrive = canDeleteDrive
                    self.canDownload = canDownload
                    self.canEdit = canEdit
                    self.canListChildren = canListChildren
                    self.canManageMembers = canManageMembers
                    self.canReadRevisions = canReadRevisions
                    self.canRename = canRename
                    self.canRenameDrive = canRenameDrive
                    self.canResetDriveRestrictions = canResetDriveRestrictions
                    self.canShare = canShare
                    self.canTrashChildren = canTrashChildren
                }
                public enum CodingKeys: String, CodingKey {
                    case canAddChildren
                    case canChangeCopyRequiresWriterPermissionRestriction
                    case canChangeDomainUsersOnlyRestriction
                    case canChangeDriveBackground
                    case canChangeDriveMembersOnlyRestriction
                    case canChangeSharingFoldersRequiresOrganizerPermissionRestriction
                    case canComment
                    case canCopy
                    case canDeleteChildren
                    case canDeleteDrive
                    case canDownload
                    case canEdit
                    case canListChildren
                    case canManageMembers
                    case canReadRevisions
                    case canRename
                    case canRenameDrive
                    case canResetDriveRestrictions
                    case canShare
                    case canTrashChildren
                }
            }
            /// Output only. Capabilities the current user has on this shared drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/capabilities`.
            public var capabilities: Components.Schemas.Drive.CapabilitiesPayload?
            /// The color of this shared drive as an RGB hex string. It can only be set on a `drive.drives.update` request that does not set `themeId`.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/colorRgb`.
            public var colorRgb: Swift.String?
            /// The time at which the shared drive was created (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/createdTime`.
            public var createdTime: Foundation.Date?
            /// Whether the shared drive is hidden from default view.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/hidden`.
            public var hidden: Swift.Bool?
            /// Output only. The ID of this shared drive which is also the ID of the top level folder of this shared drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/id`.
            public var id: Swift.String?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#drive"`.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/kind`.
            public var kind: Swift.String?
            /// The name of this shared drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/name`.
            public var name: Swift.String?
            /// Output only. The organizational unit of this shared drive. This field is only populated on `drives.list` responses when the `useDomainAdminAccess` parameter is set to `true`.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/orgUnitId`.
            public var orgUnitId: Swift.String?
            /// A set of restrictions that apply to this shared drive or items inside this shared drive. Note that restrictions can't be set when creating a shared drive. To add a restriction, first create a shared drive and then use `drives.update` to add restrictions.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/restrictions`.
            public struct RestrictionsPayload: Codable, Hashable, Sendable {
                /// Whether administrative privileges on this shared drive are required to modify restrictions.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/restrictions/adminManagedRestrictions`.
                public var adminManagedRestrictions: Swift.Bool?
                /// Whether the options to copy, print, or download files inside this shared drive, should be disabled for readers and commenters. When this restriction is set to `true`, it will override the similarly named field to `true` for any file inside this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/restrictions/copyRequiresWriterPermission`.
                public var copyRequiresWriterPermission: Swift.Bool?
                /// Whether access to this shared drive and items inside this shared drive is restricted to users of the domain to which this shared drive belongs. This restriction may be overridden by other sharing policies controlled outside of this shared drive.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/restrictions/domainUsersOnly`.
                public var domainUsersOnly: Swift.Bool?
                /// Whether access to items inside this shared drive is restricted to its members.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/restrictions/driveMembersOnly`.
                public var driveMembersOnly: Swift.Bool?
                /// If true, only users with the organizer role can share folders. If false, users with either the organizer role or the file organizer role can share folders.
                ///
                /// - Remark: Generated from `#/components/schemas/Drive/restrictions/sharingFoldersRequiresOrganizerPermission`.
                public var sharingFoldersRequiresOrganizerPermission: Swift.Bool?
                /// Creates a new `RestrictionsPayload`.
                ///
                /// - Parameters:
                ///   - adminManagedRestrictions: Whether administrative privileges on this shared drive are required to modify restrictions.
                ///   - copyRequiresWriterPermission: Whether the options to copy, print, or download files inside this shared drive, should be disabled for readers and commenters. When this restriction is set to `true`, it will override the similarly named field to `true` for any file inside this shared drive.
                ///   - domainUsersOnly: Whether access to this shared drive and items inside this shared drive is restricted to users of the domain to which this shared drive belongs. This restriction may be overridden by other sharing policies controlled outside of this shared drive.
                ///   - driveMembersOnly: Whether access to items inside this shared drive is restricted to its members.
                ///   - sharingFoldersRequiresOrganizerPermission: If true, only users with the organizer role can share folders. If false, users with either the organizer role or the file organizer role can share folders.
                public init(
                    adminManagedRestrictions: Swift.Bool? = nil,
                    copyRequiresWriterPermission: Swift.Bool? = nil,
                    domainUsersOnly: Swift.Bool? = nil,
                    driveMembersOnly: Swift.Bool? = nil,
                    sharingFoldersRequiresOrganizerPermission: Swift.Bool? = nil
                ) {
                    self.adminManagedRestrictions = adminManagedRestrictions
                    self.copyRequiresWriterPermission = copyRequiresWriterPermission
                    self.domainUsersOnly = domainUsersOnly
                    self.driveMembersOnly = driveMembersOnly
                    self.sharingFoldersRequiresOrganizerPermission = sharingFoldersRequiresOrganizerPermission
                }
                public enum CodingKeys: String, CodingKey {
                    case adminManagedRestrictions
                    case copyRequiresWriterPermission
                    case domainUsersOnly
                    case driveMembersOnly
                    case sharingFoldersRequiresOrganizerPermission
                }
            }
            /// A set of restrictions that apply to this shared drive or items inside this shared drive. Note that restrictions can't be set when creating a shared drive. To add a restriction, first create a shared drive and then use `drives.update` to add restrictions.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/restrictions`.
            public var restrictions: Components.Schemas.Drive.RestrictionsPayload?
            /// The ID of the theme from which the background image and color will be set. The set of possible `driveThemes` can be retrieved from a `drive.about.get` response. When not specified on a `drive.drives.create` request, a random theme is chosen from which the background image and color are set. This is a write-only field; it can only be set on requests that don't set `colorRgb` or `backgroundImageFile`.
            ///
            /// - Remark: Generated from `#/components/schemas/Drive/themeId`.
            public var themeId: Swift.String?
            /// Creates a new `Drive`.
            ///
            /// - Parameters:
            ///   - backgroundImageFile: An image file and cropping parameters from which a background image for this shared drive is set. This is a write only field; it can only be set on `drive.drives.update` requests that don't set `themeId`. When specified, all fields of the `backgroundImageFile` must be set.
            ///   - backgroundImageLink: Output only. A short-lived link to this shared drive's background image.
            ///   - capabilities: Output only. Capabilities the current user has on this shared drive.
            ///   - colorRgb: The color of this shared drive as an RGB hex string. It can only be set on a `drive.drives.update` request that does not set `themeId`.
            ///   - createdTime: The time at which the shared drive was created (RFC 3339 date-time).
            ///   - hidden: Whether the shared drive is hidden from default view.
            ///   - id: Output only. The ID of this shared drive which is also the ID of the top level folder of this shared drive.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#drive"`.
            ///   - name: The name of this shared drive.
            ///   - orgUnitId: Output only. The organizational unit of this shared drive. This field is only populated on `drives.list` responses when the `useDomainAdminAccess` parameter is set to `true`.
            ///   - restrictions: A set of restrictions that apply to this shared drive or items inside this shared drive. Note that restrictions can't be set when creating a shared drive. To add a restriction, first create a shared drive and then use `drives.update` to add restrictions.
            ///   - themeId: The ID of the theme from which the background image and color will be set. The set of possible `driveThemes` can be retrieved from a `drive.about.get` response. When not specified on a `drive.drives.create` request, a random theme is chosen from which the background image and color are set. This is a write-only field; it can only be set on requests that don't set `colorRgb` or `backgroundImageFile`.
            public init(
                backgroundImageFile: Components.Schemas.Drive.BackgroundImageFilePayload? = nil,
                backgroundImageLink: Swift.String? = nil,
                capabilities: Components.Schemas.Drive.CapabilitiesPayload? = nil,
                colorRgb: Swift.String? = nil,
                createdTime: Foundation.Date? = nil,
                hidden: Swift.Bool? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                name: Swift.String? = nil,
                orgUnitId: Swift.String? = nil,
                restrictions: Components.Schemas.Drive.RestrictionsPayload? = nil,
                themeId: Swift.String? = nil
            ) {
                self.backgroundImageFile = backgroundImageFile
                self.backgroundImageLink = backgroundImageLink
                self.capabilities = capabilities
                self.colorRgb = colorRgb
                self.createdTime = createdTime
                self.hidden = hidden
                self.id = id
                self.kind = kind
                self.name = name
                self.orgUnitId = orgUnitId
                self.restrictions = restrictions
                self.themeId = themeId
            }
            public enum CodingKeys: String, CodingKey {
                case backgroundImageFile
                case backgroundImageLink
                case capabilities
                case colorRgb
                case createdTime
                case hidden
                case id
                case kind
                case name
                case orgUnitId
                case restrictions
                case themeId
            }
        }
        /// A list of shared drives.
        ///
        /// - Remark: Generated from `#/components/schemas/DriveList`.
        public struct DriveList: Codable, Hashable, Sendable {
            /// The list of shared drives. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/DriveList/drives`.
            public var drives: [Components.Schemas.Drive]?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#driveList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/DriveList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of shared drives. This will be absent if the end of the list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/DriveList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// Creates a new `DriveList`.
            ///
            /// - Parameters:
            ///   - drives: The list of shared drives. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#driveList"`.
            ///   - nextPageToken: The page token for the next page of shared drives. This will be absent if the end of the list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            public init(
                drives: [Components.Schemas.Drive]? = nil,
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil
            ) {
                self.drives = drives
                self.kind = kind
                self.nextPageToken = nextPageToken
            }
            public enum CodingKeys: String, CodingKey {
                case drives
                case kind
                case nextPageToken
            }
        }
        /// The metadata for a file. Some resource methods (such as `files.update`) require a `fileId`. Use the `files.list` method to retrieve the ID for a file.
        ///
        /// - Remark: Generated from `#/components/schemas/File`.
        public struct File: Codable, Hashable, Sendable {
            /// A collection of arbitrary key-value pairs which are private to the requesting app.
            /// Entries with null values are cleared in update and copy requests. These properties can only be retrieved using an authenticated request. An authenticated request uses an access token obtained with a OAuth 2 client ID. You cannot use an API key to retrieve private properties.
            ///
            /// - Remark: Generated from `#/components/schemas/File/appProperties`.
            public struct AppPropertiesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `AppPropertiesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A collection of arbitrary key-value pairs which are private to the requesting app.
            /// Entries with null values are cleared in update and copy requests. These properties can only be retrieved using an authenticated request. An authenticated request uses an access token obtained with a OAuth 2 client ID. You cannot use an API key to retrieve private properties.
            ///
            /// - Remark: Generated from `#/components/schemas/File/appProperties`.
            public var appProperties: Components.Schemas.File.AppPropertiesPayload?
            /// Output only. Capabilities the current user has on this file. Each capability corresponds to a fine-grained action that a user may take.
            ///
            /// - Remark: Generated from `#/components/schemas/File/capabilities`.
            public struct CapabilitiesPayload: Codable, Hashable, Sendable {
                /// Output only. Whether the current user is the pending owner of the file. Not populated for shared drive files.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canAcceptOwnership`.
                public var canAcceptOwnership: Swift.Bool?
                /// Output only. Whether the current user can add children to this folder. This is always false when the item is not a folder.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canAddChildren`.
                public var canAddChildren: Swift.Bool?
                /// Output only. Whether the current user can add a folder from another drive (different shared drive or My Drive) to this folder. This is false when the item is not a folder. Only populated for items in shared drives.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canAddFolderFromAnotherDrive`.
                public var canAddFolderFromAnotherDrive: Swift.Bool?
                /// Output only. Whether the current user can add a parent for the item without removing an existing parent in the same request. Not populated for shared drive files.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canAddMyDriveParent`.
                public var canAddMyDriveParent: Swift.Bool?
                /// Output only. Whether the current user can change the `copyRequiresWriterPermission` restriction of this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canChangeCopyRequiresWriterPermission`.
                public var canChangeCopyRequiresWriterPermission: Swift.Bool?
                /// Output only. Whether the current user can change the securityUpdateEnabled field on link share metadata.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canChangeSecurityUpdateEnabled`.
                public var canChangeSecurityUpdateEnabled: Swift.Bool?
                /// Deprecated: Output only.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canChangeViewersCanCopyContent`.
                @available(*, deprecated)
                public var canChangeViewersCanCopyContent: Swift.Bool?
                /// Output only. Whether the current user can comment on this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canComment`.
                public var canComment: Swift.Bool?
                /// Output only. Whether the current user can copy this file. For an item in a shared drive, whether the current user can copy non-folder descendants of this item, or this item itself if it is not a folder.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canCopy`.
                public var canCopy: Swift.Bool?
                /// Output only. Whether the current user can delete this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canDelete`.
                public var canDelete: Swift.Bool?
                /// Output only. Whether the current user can delete children of this folder. This is false when the item is not a folder. Only populated for items in shared drives.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canDeleteChildren`.
                public var canDeleteChildren: Swift.Bool?
                /// Output only. Whether the current user can download this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canDownload`.
                public var canDownload: Swift.Bool?
                /// Output only. Whether the current user can edit this file. Other factors may limit the type of changes a user can make to a file. For example, see `canChangeCopyRequiresWriterPermission` or `canModifyContent`.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canEdit`.
                public var canEdit: Swift.Bool?
                /// Output only. Whether the current user can list the children of this folder. This is always false when the item is not a folder.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canListChildren`.
                public var canListChildren: Swift.Bool?
                /// Output only. Whether the current user can modify the content of this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canModifyContent`.
                public var canModifyContent: Swift.Bool?
                /// Deprecated: Output only. Use one of `canModifyEditorContentRestriction`, `canModifyOwnerContentRestriction` or `canRemoveContentRestriction`.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canModifyContentRestriction`.
                @available(*, deprecated)
                public var canModifyContentRestriction: Swift.Bool?
                /// Output only. Whether the current user can add or modify content restrictions on the file which are editor restricted.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canModifyEditorContentRestriction`.
                public var canModifyEditorContentRestriction: Swift.Bool?
                /// Output only. Whether the current user can modify the labels on the file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canModifyLabels`.
                public var canModifyLabels: Swift.Bool?
                /// Output only. Whether the current user can add or modify content restrictions which are owner restricted.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canModifyOwnerContentRestriction`.
                public var canModifyOwnerContentRestriction: Swift.Bool?
                /// Output only. Whether the current user can move children of this folder outside of the shared drive. This is false when the item is not a folder. Only populated for items in shared drives.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveChildrenOutOfDrive`.
                public var canMoveChildrenOutOfDrive: Swift.Bool?
                /// Deprecated: Output only. Use `canMoveChildrenOutOfDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveChildrenOutOfTeamDrive`.
                @available(*, deprecated)
                public var canMoveChildrenOutOfTeamDrive: Swift.Bool?
                /// Output only. Whether the current user can move children of this folder within this drive. This is false when the item is not a folder. Note that a request to move the child may still fail depending on the current user's access to the child and to the destination folder.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveChildrenWithinDrive`.
                public var canMoveChildrenWithinDrive: Swift.Bool?
                /// Deprecated: Output only. Use `canMoveChildrenWithinDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveChildrenWithinTeamDrive`.
                @available(*, deprecated)
                public var canMoveChildrenWithinTeamDrive: Swift.Bool?
                /// Deprecated: Output only. Use `canMoveItemOutOfDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveItemIntoTeamDrive`.
                @available(*, deprecated)
                public var canMoveItemIntoTeamDrive: Swift.Bool?
                /// Output only. Whether the current user can move this item outside of this drive by changing its parent. Note that a request to change the parent of the item may still fail depending on the new parent that is being added.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveItemOutOfDrive`.
                public var canMoveItemOutOfDrive: Swift.Bool?
                /// Deprecated: Output only. Use `canMoveItemOutOfDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveItemOutOfTeamDrive`.
                @available(*, deprecated)
                public var canMoveItemOutOfTeamDrive: Swift.Bool?
                /// Output only. Whether the current user can move this item within this drive. Note that a request to change the parent of the item may still fail depending on the new parent that is being added and the parent that is being removed.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveItemWithinDrive`.
                public var canMoveItemWithinDrive: Swift.Bool?
                /// Deprecated: Output only. Use `canMoveItemWithinDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveItemWithinTeamDrive`.
                @available(*, deprecated)
                public var canMoveItemWithinTeamDrive: Swift.Bool?
                /// Deprecated: Output only. Use `canMoveItemWithinDrive` or `canMoveItemOutOfDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canMoveTeamDriveItem`.
                @available(*, deprecated)
                public var canMoveTeamDriveItem: Swift.Bool?
                /// Output only. Whether the current user can read the shared drive to which this file belongs. Only populated for items in shared drives.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canReadDrive`.
                public var canReadDrive: Swift.Bool?
                /// Output only. Whether the current user can read the labels on the file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canReadLabels`.
                public var canReadLabels: Swift.Bool?
                /// Output only. Whether the current user can read the revisions resource of this file. For a shared drive item, whether revisions of non-folder descendants of this item, or this item itself if it is not a folder, can be read.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canReadRevisions`.
                public var canReadRevisions: Swift.Bool?
                /// Deprecated: Output only. Use `canReadDrive` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canReadTeamDrive`.
                @available(*, deprecated)
                public var canReadTeamDrive: Swift.Bool?
                /// Output only. Whether the current user can remove children from this folder. This is always false when the item is not a folder. For a folder in a shared drive, use `canDeleteChildren` or `canTrashChildren` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canRemoveChildren`.
                public var canRemoveChildren: Swift.Bool?
                /// Output only. Whether there is a content restriction on the file that can be removed by the current user.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canRemoveContentRestriction`.
                public var canRemoveContentRestriction: Swift.Bool?
                /// Output only. Whether the current user can remove a parent from the item without adding another parent in the same request. Not populated for shared drive files.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canRemoveMyDriveParent`.
                public var canRemoveMyDriveParent: Swift.Bool?
                /// Output only. Whether the current user can rename this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canRename`.
                public var canRename: Swift.Bool?
                /// Output only. Whether the current user can modify the sharing settings for this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canShare`.
                public var canShare: Swift.Bool?
                /// Output only. Whether the current user can move this file to trash.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canTrash`.
                public var canTrash: Swift.Bool?
                /// Output only. Whether the current user can trash children of this folder. This is false when the item is not a folder. Only populated for items in shared drives.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canTrashChildren`.
                public var canTrashChildren: Swift.Bool?
                /// Output only. Whether the current user can restore this file from trash.
                ///
                /// - Remark: Generated from `#/components/schemas/File/capabilities/canUntrash`.
                public var canUntrash: Swift.Bool?
                /// Creates a new `CapabilitiesPayload`.
                ///
                /// - Parameters:
                ///   - canAcceptOwnership: Output only. Whether the current user is the pending owner of the file. Not populated for shared drive files.
                ///   - canAddChildren: Output only. Whether the current user can add children to this folder. This is always false when the item is not a folder.
                ///   - canAddFolderFromAnotherDrive: Output only. Whether the current user can add a folder from another drive (different shared drive or My Drive) to this folder. This is false when the item is not a folder. Only populated for items in shared drives.
                ///   - canAddMyDriveParent: Output only. Whether the current user can add a parent for the item without removing an existing parent in the same request. Not populated for shared drive files.
                ///   - canChangeCopyRequiresWriterPermission: Output only. Whether the current user can change the `copyRequiresWriterPermission` restriction of this file.
                ///   - canChangeSecurityUpdateEnabled: Output only. Whether the current user can change the securityUpdateEnabled field on link share metadata.
                ///   - canChangeViewersCanCopyContent: Deprecated: Output only.
                ///   - canComment: Output only. Whether the current user can comment on this file.
                ///   - canCopy: Output only. Whether the current user can copy this file. For an item in a shared drive, whether the current user can copy non-folder descendants of this item, or this item itself if it is not a folder.
                ///   - canDelete: Output only. Whether the current user can delete this file.
                ///   - canDeleteChildren: Output only. Whether the current user can delete children of this folder. This is false when the item is not a folder. Only populated for items in shared drives.
                ///   - canDownload: Output only. Whether the current user can download this file.
                ///   - canEdit: Output only. Whether the current user can edit this file. Other factors may limit the type of changes a user can make to a file. For example, see `canChangeCopyRequiresWriterPermission` or `canModifyContent`.
                ///   - canListChildren: Output only. Whether the current user can list the children of this folder. This is always false when the item is not a folder.
                ///   - canModifyContent: Output only. Whether the current user can modify the content of this file.
                ///   - canModifyContentRestriction: Deprecated: Output only. Use one of `canModifyEditorContentRestriction`, `canModifyOwnerContentRestriction` or `canRemoveContentRestriction`.
                ///   - canModifyEditorContentRestriction: Output only. Whether the current user can add or modify content restrictions on the file which are editor restricted.
                ///   - canModifyLabels: Output only. Whether the current user can modify the labels on the file.
                ///   - canModifyOwnerContentRestriction: Output only. Whether the current user can add or modify content restrictions which are owner restricted.
                ///   - canMoveChildrenOutOfDrive: Output only. Whether the current user can move children of this folder outside of the shared drive. This is false when the item is not a folder. Only populated for items in shared drives.
                ///   - canMoveChildrenOutOfTeamDrive: Deprecated: Output only. Use `canMoveChildrenOutOfDrive` instead.
                ///   - canMoveChildrenWithinDrive: Output only. Whether the current user can move children of this folder within this drive. This is false when the item is not a folder. Note that a request to move the child may still fail depending on the current user's access to the child and to the destination folder.
                ///   - canMoveChildrenWithinTeamDrive: Deprecated: Output only. Use `canMoveChildrenWithinDrive` instead.
                ///   - canMoveItemIntoTeamDrive: Deprecated: Output only. Use `canMoveItemOutOfDrive` instead.
                ///   - canMoveItemOutOfDrive: Output only. Whether the current user can move this item outside of this drive by changing its parent. Note that a request to change the parent of the item may still fail depending on the new parent that is being added.
                ///   - canMoveItemOutOfTeamDrive: Deprecated: Output only. Use `canMoveItemOutOfDrive` instead.
                ///   - canMoveItemWithinDrive: Output only. Whether the current user can move this item within this drive. Note that a request to change the parent of the item may still fail depending on the new parent that is being added and the parent that is being removed.
                ///   - canMoveItemWithinTeamDrive: Deprecated: Output only. Use `canMoveItemWithinDrive` instead.
                ///   - canMoveTeamDriveItem: Deprecated: Output only. Use `canMoveItemWithinDrive` or `canMoveItemOutOfDrive` instead.
                ///   - canReadDrive: Output only. Whether the current user can read the shared drive to which this file belongs. Only populated for items in shared drives.
                ///   - canReadLabels: Output only. Whether the current user can read the labels on the file.
                ///   - canReadRevisions: Output only. Whether the current user can read the revisions resource of this file. For a shared drive item, whether revisions of non-folder descendants of this item, or this item itself if it is not a folder, can be read.
                ///   - canReadTeamDrive: Deprecated: Output only. Use `canReadDrive` instead.
                ///   - canRemoveChildren: Output only. Whether the current user can remove children from this folder. This is always false when the item is not a folder. For a folder in a shared drive, use `canDeleteChildren` or `canTrashChildren` instead.
                ///   - canRemoveContentRestriction: Output only. Whether there is a content restriction on the file that can be removed by the current user.
                ///   - canRemoveMyDriveParent: Output only. Whether the current user can remove a parent from the item without adding another parent in the same request. Not populated for shared drive files.
                ///   - canRename: Output only. Whether the current user can rename this file.
                ///   - canShare: Output only. Whether the current user can modify the sharing settings for this file.
                ///   - canTrash: Output only. Whether the current user can move this file to trash.
                ///   - canTrashChildren: Output only. Whether the current user can trash children of this folder. This is false when the item is not a folder. Only populated for items in shared drives.
                ///   - canUntrash: Output only. Whether the current user can restore this file from trash.
                public init(
                    canAcceptOwnership: Swift.Bool? = nil,
                    canAddChildren: Swift.Bool? = nil,
                    canAddFolderFromAnotherDrive: Swift.Bool? = nil,
                    canAddMyDriveParent: Swift.Bool? = nil,
                    canChangeCopyRequiresWriterPermission: Swift.Bool? = nil,
                    canChangeSecurityUpdateEnabled: Swift.Bool? = nil,
                    canChangeViewersCanCopyContent: Swift.Bool? = nil,
                    canComment: Swift.Bool? = nil,
                    canCopy: Swift.Bool? = nil,
                    canDelete: Swift.Bool? = nil,
                    canDeleteChildren: Swift.Bool? = nil,
                    canDownload: Swift.Bool? = nil,
                    canEdit: Swift.Bool? = nil,
                    canListChildren: Swift.Bool? = nil,
                    canModifyContent: Swift.Bool? = nil,
                    canModifyContentRestriction: Swift.Bool? = nil,
                    canModifyEditorContentRestriction: Swift.Bool? = nil,
                    canModifyLabels: Swift.Bool? = nil,
                    canModifyOwnerContentRestriction: Swift.Bool? = nil,
                    canMoveChildrenOutOfDrive: Swift.Bool? = nil,
                    canMoveChildrenOutOfTeamDrive: Swift.Bool? = nil,
                    canMoveChildrenWithinDrive: Swift.Bool? = nil,
                    canMoveChildrenWithinTeamDrive: Swift.Bool? = nil,
                    canMoveItemIntoTeamDrive: Swift.Bool? = nil,
                    canMoveItemOutOfDrive: Swift.Bool? = nil,
                    canMoveItemOutOfTeamDrive: Swift.Bool? = nil,
                    canMoveItemWithinDrive: Swift.Bool? = nil,
                    canMoveItemWithinTeamDrive: Swift.Bool? = nil,
                    canMoveTeamDriveItem: Swift.Bool? = nil,
                    canReadDrive: Swift.Bool? = nil,
                    canReadLabels: Swift.Bool? = nil,
                    canReadRevisions: Swift.Bool? = nil,
                    canReadTeamDrive: Swift.Bool? = nil,
                    canRemoveChildren: Swift.Bool? = nil,
                    canRemoveContentRestriction: Swift.Bool? = nil,
                    canRemoveMyDriveParent: Swift.Bool? = nil,
                    canRename: Swift.Bool? = nil,
                    canShare: Swift.Bool? = nil,
                    canTrash: Swift.Bool? = nil,
                    canTrashChildren: Swift.Bool? = nil,
                    canUntrash: Swift.Bool? = nil
                ) {
                    self.canAcceptOwnership = canAcceptOwnership
                    self.canAddChildren = canAddChildren
                    self.canAddFolderFromAnotherDrive = canAddFolderFromAnotherDrive
                    self.canAddMyDriveParent = canAddMyDriveParent
                    self.canChangeCopyRequiresWriterPermission = canChangeCopyRequiresWriterPermission
                    self.canChangeSecurityUpdateEnabled = canChangeSecurityUpdateEnabled
                    self.canChangeViewersCanCopyContent = canChangeViewersCanCopyContent
                    self.canComment = canComment
                    self.canCopy = canCopy
                    self.canDelete = canDelete
                    self.canDeleteChildren = canDeleteChildren
                    self.canDownload = canDownload
                    self.canEdit = canEdit
                    self.canListChildren = canListChildren
                    self.canModifyContent = canModifyContent
                    self.canModifyContentRestriction = canModifyContentRestriction
                    self.canModifyEditorContentRestriction = canModifyEditorContentRestriction
                    self.canModifyLabels = canModifyLabels
                    self.canModifyOwnerContentRestriction = canModifyOwnerContentRestriction
                    self.canMoveChildrenOutOfDrive = canMoveChildrenOutOfDrive
                    self.canMoveChildrenOutOfTeamDrive = canMoveChildrenOutOfTeamDrive
                    self.canMoveChildrenWithinDrive = canMoveChildrenWithinDrive
                    self.canMoveChildrenWithinTeamDrive = canMoveChildrenWithinTeamDrive
                    self.canMoveItemIntoTeamDrive = canMoveItemIntoTeamDrive
                    self.canMoveItemOutOfDrive = canMoveItemOutOfDrive
                    self.canMoveItemOutOfTeamDrive = canMoveItemOutOfTeamDrive
                    self.canMoveItemWithinDrive = canMoveItemWithinDrive
                    self.canMoveItemWithinTeamDrive = canMoveItemWithinTeamDrive
                    self.canMoveTeamDriveItem = canMoveTeamDriveItem
                    self.canReadDrive = canReadDrive
                    self.canReadLabels = canReadLabels
                    self.canReadRevisions = canReadRevisions
                    self.canReadTeamDrive = canReadTeamDrive
                    self.canRemoveChildren = canRemoveChildren
                    self.canRemoveContentRestriction = canRemoveContentRestriction
                    self.canRemoveMyDriveParent = canRemoveMyDriveParent
                    self.canRename = canRename
                    self.canShare = canShare
                    self.canTrash = canTrash
                    self.canTrashChildren = canTrashChildren
                    self.canUntrash = canUntrash
                }
                public enum CodingKeys: String, CodingKey {
                    case canAcceptOwnership
                    case canAddChildren
                    case canAddFolderFromAnotherDrive
                    case canAddMyDriveParent
                    case canChangeCopyRequiresWriterPermission
                    case canChangeSecurityUpdateEnabled
                    case canChangeViewersCanCopyContent
                    case canComment
                    case canCopy
                    case canDelete
                    case canDeleteChildren
                    case canDownload
                    case canEdit
                    case canListChildren
                    case canModifyContent
                    case canModifyContentRestriction
                    case canModifyEditorContentRestriction
                    case canModifyLabels
                    case canModifyOwnerContentRestriction
                    case canMoveChildrenOutOfDrive
                    case canMoveChildrenOutOfTeamDrive
                    case canMoveChildrenWithinDrive
                    case canMoveChildrenWithinTeamDrive
                    case canMoveItemIntoTeamDrive
                    case canMoveItemOutOfDrive
                    case canMoveItemOutOfTeamDrive
                    case canMoveItemWithinDrive
                    case canMoveItemWithinTeamDrive
                    case canMoveTeamDriveItem
                    case canReadDrive
                    case canReadLabels
                    case canReadRevisions
                    case canReadTeamDrive
                    case canRemoveChildren
                    case canRemoveContentRestriction
                    case canRemoveMyDriveParent
                    case canRename
                    case canShare
                    case canTrash
                    case canTrashChildren
                    case canUntrash
                }
            }
            /// Output only. Capabilities the current user has on this file. Each capability corresponds to a fine-grained action that a user may take.
            ///
            /// - Remark: Generated from `#/components/schemas/File/capabilities`.
            public var capabilities: Components.Schemas.File.CapabilitiesPayload?
            /// Additional information about the content of the file. These fields are never populated in responses.
            ///
            /// - Remark: Generated from `#/components/schemas/File/contentHints`.
            public struct ContentHintsPayload: Codable, Hashable, Sendable {
                /// Text to be indexed for the file to improve fullText queries. This is limited to 128KB in length and may contain HTML elements.
                ///
                /// - Remark: Generated from `#/components/schemas/File/contentHints/indexableText`.
                public var indexableText: Swift.String?
                /// A thumbnail for the file. This will only be used if Google Drive cannot generate a standard thumbnail.
                ///
                /// - Remark: Generated from `#/components/schemas/File/contentHints/thumbnail`.
                public struct ThumbnailPayload: Codable, Hashable, Sendable {
                    /// The thumbnail data encoded with URL-safe Base64 (RFC 4648 section 5).
                    ///
                    /// - Remark: Generated from `#/components/schemas/File/contentHints/thumbnail/image`.
                    public var image: OpenAPIRuntime.Base64EncodedData?
                    /// The MIME type of the thumbnail.
                    ///
                    /// - Remark: Generated from `#/components/schemas/File/contentHints/thumbnail/mimeType`.
                    public var mimeType: Swift.String?
                    /// Creates a new `ThumbnailPayload`.
                    ///
                    /// - Parameters:
                    ///   - image: The thumbnail data encoded with URL-safe Base64 (RFC 4648 section 5).
                    ///   - mimeType: The MIME type of the thumbnail.
                    public init(
                        image: OpenAPIRuntime.Base64EncodedData? = nil,
                        mimeType: Swift.String? = nil
                    ) {
                        self.image = image
                        self.mimeType = mimeType
                    }
                    public enum CodingKeys: String, CodingKey {
                        case image
                        case mimeType
                    }
                }
                /// A thumbnail for the file. This will only be used if Google Drive cannot generate a standard thumbnail.
                ///
                /// - Remark: Generated from `#/components/schemas/File/contentHints/thumbnail`.
                public var thumbnail: Components.Schemas.File.ContentHintsPayload.ThumbnailPayload?
                /// Creates a new `ContentHintsPayload`.
                ///
                /// - Parameters:
                ///   - indexableText: Text to be indexed for the file to improve fullText queries. This is limited to 128KB in length and may contain HTML elements.
                ///   - thumbnail: A thumbnail for the file. This will only be used if Google Drive cannot generate a standard thumbnail.
                public init(
                    indexableText: Swift.String? = nil,
                    thumbnail: Components.Schemas.File.ContentHintsPayload.ThumbnailPayload? = nil
                ) {
                    self.indexableText = indexableText
                    self.thumbnail = thumbnail
                }
                public enum CodingKeys: String, CodingKey {
                    case indexableText
                    case thumbnail
                }
            }
            /// Additional information about the content of the file. These fields are never populated in responses.
            ///
            /// - Remark: Generated from `#/components/schemas/File/contentHints`.
            public var contentHints: Components.Schemas.File.ContentHintsPayload?
            /// Restrictions for accessing the content of the file. Only populated if such a restriction exists.
            ///
            /// - Remark: Generated from `#/components/schemas/File/contentRestrictions`.
            public var contentRestrictions: [Components.Schemas.ContentRestriction]?
            /// Whether the options to copy, print, or download this file, should be disabled for readers and commenters.
            ///
            /// - Remark: Generated from `#/components/schemas/File/copyRequiresWriterPermission`.
            public var copyRequiresWriterPermission: Swift.Bool?
            /// The time at which the file was created (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/File/createdTime`.
            public var createdTime: Foundation.Date?
            /// A short description of the file.
            ///
            /// - Remark: Generated from `#/components/schemas/File/description`.
            public var description: Swift.String?
            /// Output only. ID of the shared drive the file resides in. Only populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/driveId`.
            public var driveId: Swift.String?
            /// Output only. Whether the file has been explicitly trashed, as opposed to recursively trashed from a parent folder.
            ///
            /// - Remark: Generated from `#/components/schemas/File/explicitlyTrashed`.
            public var explicitlyTrashed: Swift.Bool?
            /// Output only. Links for exporting Docs Editors files to specific formats.
            ///
            /// - Remark: Generated from `#/components/schemas/File/exportLinks`.
            public struct ExportLinksPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `ExportLinksPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// Output only. Links for exporting Docs Editors files to specific formats.
            ///
            /// - Remark: Generated from `#/components/schemas/File/exportLinks`.
            public var exportLinks: Components.Schemas.File.ExportLinksPayload?
            /// Output only. The final component of `fullFileExtension`. This is only available for files with binary content in Google Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/File/fileExtension`.
            public var fileExtension: Swift.String?
            /// The color for a folder or a shortcut to a folder as an RGB hex string. The supported colors are published in the `folderColorPalette` field of the About resource. If an unsupported color is specified, the closest color in the palette is used instead.
            ///
            /// - Remark: Generated from `#/components/schemas/File/folderColorRgb`.
            public var folderColorRgb: Swift.String?
            /// Output only. The full file extension extracted from the `name` field. May contain multiple concatenated extensions, such as "tar.gz". This is only available for files with binary content in Google Drive. This is automatically updated when the `name` field changes, however it is not cleared if the new name does not contain a valid extension.
            ///
            /// - Remark: Generated from `#/components/schemas/File/fullFileExtension`.
            public var fullFileExtension: Swift.String?
            /// Output only. Whether there are permissions directly on this file. This field is only populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/hasAugmentedPermissions`.
            public var hasAugmentedPermissions: Swift.Bool?
            /// Output only. Whether this file has a thumbnail. This does not indicate whether the requesting app has access to the thumbnail. To check access, look for the presence of the thumbnailLink field.
            ///
            /// - Remark: Generated from `#/components/schemas/File/hasThumbnail`.
            public var hasThumbnail: Swift.Bool?
            /// Output only. The ID of the file's head revision. This is currently only available for files with binary content in Google Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/File/headRevisionId`.
            public var headRevisionId: Swift.String?
            /// Output only. A static, unauthenticated link to the file's icon.
            ///
            /// - Remark: Generated from `#/components/schemas/File/iconLink`.
            public var iconLink: Swift.String?
            /// The ID of the file.
            ///
            /// - Remark: Generated from `#/components/schemas/File/id`.
            public var id: Swift.String?
            /// Output only. Additional metadata about image media, if available.
            ///
            /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata`.
            public struct ImageMediaMetadataPayload: Codable, Hashable, Sendable {
                /// Output only. The aperture used to create the photo (f-number).
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/aperture`.
                public var aperture: Swift.Float?
                /// Output only. The make of the camera used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/cameraMake`.
                public var cameraMake: Swift.String?
                /// Output only. The model of the camera used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/cameraModel`.
                public var cameraModel: Swift.String?
                /// Output only. The color space of the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/colorSpace`.
                public var colorSpace: Swift.String?
                /// Output only. The exposure bias of the photo (APEX value).
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/exposureBias`.
                public var exposureBias: Swift.Float?
                /// Output only. The exposure mode used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/exposureMode`.
                public var exposureMode: Swift.String?
                /// Output only. The length of the exposure, in seconds.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/exposureTime`.
                public var exposureTime: Swift.Float?
                /// Output only. Whether a flash was used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/flashUsed`.
                public var flashUsed: Swift.Bool?
                /// Output only. The focal length used to create the photo, in millimeters.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/focalLength`.
                public var focalLength: Swift.Float?
                /// Output only. The height of the image in pixels.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/height`.
                public var height: Swift.Int32?
                /// Output only. The ISO speed used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/isoSpeed`.
                public var isoSpeed: Swift.Int32?
                /// Output only. The lens used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/lens`.
                public var lens: Swift.String?
                /// Output only. Geographic location information stored in the image.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/location`.
                public struct LocationPayload: Codable, Hashable, Sendable {
                    /// Output only. The altitude stored in the image.
                    ///
                    /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/location/altitude`.
                    public var altitude: Swift.Double?
                    /// Output only. The latitude stored in the image.
                    ///
                    /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/location/latitude`.
                    public var latitude: Swift.Double?
                    /// Output only. The longitude stored in the image.
                    ///
                    /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/location/longitude`.
                    public var longitude: Swift.Double?
                    /// Creates a new `LocationPayload`.
                    ///
                    /// - Parameters:
                    ///   - altitude: Output only. The altitude stored in the image.
                    ///   - latitude: Output only. The latitude stored in the image.
                    ///   - longitude: Output only. The longitude stored in the image.
                    public init(
                        altitude: Swift.Double? = nil,
                        latitude: Swift.Double? = nil,
                        longitude: Swift.Double? = nil
                    ) {
                        self.altitude = altitude
                        self.latitude = latitude
                        self.longitude = longitude
                    }
                    public enum CodingKeys: String, CodingKey {
                        case altitude
                        case latitude
                        case longitude
                    }
                }
                /// Output only. Geographic location information stored in the image.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/location`.
                public var location: Components.Schemas.File.ImageMediaMetadataPayload.LocationPayload?
                /// Output only. The smallest f-number of the lens at the focal length used to create the photo (APEX value).
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/maxApertureValue`.
                public var maxApertureValue: Swift.Float?
                /// Output only. The metering mode used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/meteringMode`.
                public var meteringMode: Swift.String?
                /// Output only. The number of clockwise 90 degree rotations applied from the image's original orientation.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/rotation`.
                public var rotation: Swift.Int32?
                /// Output only. The type of sensor used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/sensor`.
                public var sensor: Swift.String?
                /// Output only. The distance to the subject of the photo, in meters.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/subjectDistance`.
                public var subjectDistance: Swift.Int32?
                /// Output only. The date and time the photo was taken (EXIF DateTime).
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/time`.
                public var time: Swift.String?
                /// Output only. The white balance mode used to create the photo.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/whiteBalance`.
                public var whiteBalance: Swift.String?
                /// Output only. The width of the image in pixels.
                ///
                /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata/width`.
                public var width: Swift.Int32?
                /// Creates a new `ImageMediaMetadataPayload`.
                ///
                /// - Parameters:
                ///   - aperture: Output only. The aperture used to create the photo (f-number).
                ///   - cameraMake: Output only. The make of the camera used to create the photo.
                ///   - cameraModel: Output only. The model of the camera used to create the photo.
                ///   - colorSpace: Output only. The color space of the photo.
                ///   - exposureBias: Output only. The exposure bias of the photo (APEX value).
                ///   - exposureMode: Output only. The exposure mode used to create the photo.
                ///   - exposureTime: Output only. The length of the exposure, in seconds.
                ///   - flashUsed: Output only. Whether a flash was used to create the photo.
                ///   - focalLength: Output only. The focal length used to create the photo, in millimeters.
                ///   - height: Output only. The height of the image in pixels.
                ///   - isoSpeed: Output only. The ISO speed used to create the photo.
                ///   - lens: Output only. The lens used to create the photo.
                ///   - location: Output only. Geographic location information stored in the image.
                ///   - maxApertureValue: Output only. The smallest f-number of the lens at the focal length used to create the photo (APEX value).
                ///   - meteringMode: Output only. The metering mode used to create the photo.
                ///   - rotation: Output only. The number of clockwise 90 degree rotations applied from the image's original orientation.
                ///   - sensor: Output only. The type of sensor used to create the photo.
                ///   - subjectDistance: Output only. The distance to the subject of the photo, in meters.
                ///   - time: Output only. The date and time the photo was taken (EXIF DateTime).
                ///   - whiteBalance: Output only. The white balance mode used to create the photo.
                ///   - width: Output only. The width of the image in pixels.
                public init(
                    aperture: Swift.Float? = nil,
                    cameraMake: Swift.String? = nil,
                    cameraModel: Swift.String? = nil,
                    colorSpace: Swift.String? = nil,
                    exposureBias: Swift.Float? = nil,
                    exposureMode: Swift.String? = nil,
                    exposureTime: Swift.Float? = nil,
                    flashUsed: Swift.Bool? = nil,
                    focalLength: Swift.Float? = nil,
                    height: Swift.Int32? = nil,
                    isoSpeed: Swift.Int32? = nil,
                    lens: Swift.String? = nil,
                    location: Components.Schemas.File.ImageMediaMetadataPayload.LocationPayload? = nil,
                    maxApertureValue: Swift.Float? = nil,
                    meteringMode: Swift.String? = nil,
                    rotation: Swift.Int32? = nil,
                    sensor: Swift.String? = nil,
                    subjectDistance: Swift.Int32? = nil,
                    time: Swift.String? = nil,
                    whiteBalance: Swift.String? = nil,
                    width: Swift.Int32? = nil
                ) {
                    self.aperture = aperture
                    self.cameraMake = cameraMake
                    self.cameraModel = cameraModel
                    self.colorSpace = colorSpace
                    self.exposureBias = exposureBias
                    self.exposureMode = exposureMode
                    self.exposureTime = exposureTime
                    self.flashUsed = flashUsed
                    self.focalLength = focalLength
                    self.height = height
                    self.isoSpeed = isoSpeed
                    self.lens = lens
                    self.location = location
                    self.maxApertureValue = maxApertureValue
                    self.meteringMode = meteringMode
                    self.rotation = rotation
                    self.sensor = sensor
                    self.subjectDistance = subjectDistance
                    self.time = time
                    self.whiteBalance = whiteBalance
                    self.width = width
                }
                public enum CodingKeys: String, CodingKey {
                    case aperture
                    case cameraMake
                    case cameraModel
                    case colorSpace
                    case exposureBias
                    case exposureMode
                    case exposureTime
                    case flashUsed
                    case focalLength
                    case height
                    case isoSpeed
                    case lens
                    case location
                    case maxApertureValue
                    case meteringMode
                    case rotation
                    case sensor
                    case subjectDistance
                    case time
                    case whiteBalance
                    case width
                }
            }
            /// Output only. Additional metadata about image media, if available.
            ///
            /// - Remark: Generated from `#/components/schemas/File/imageMediaMetadata`.
            public var imageMediaMetadata: Components.Schemas.File.ImageMediaMetadataPayload?
            /// Output only. Whether the file was created or opened by the requesting app.
            ///
            /// - Remark: Generated from `#/components/schemas/File/isAppAuthorized`.
            public var isAppAuthorized: Swift.Bool?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#file"`.
            ///
            /// - Remark: Generated from `#/components/schemas/File/kind`.
            public var kind: Swift.String?
            /// Output only. An overview of the labels on the file.
            ///
            /// - Remark: Generated from `#/components/schemas/File/labelInfo`.
            public struct LabelInfoPayload: Codable, Hashable, Sendable {
                /// Output only. The set of labels on the file as requested by the label IDs in the `includeLabels` parameter. By default, no labels are returned.
                ///
                /// - Remark: Generated from `#/components/schemas/File/labelInfo/labels`.
                public var labels: [Components.Schemas.Label]?
                /// Creates a new `LabelInfoPayload`.
                ///
                /// - Parameters:
                ///   - labels: Output only. The set of labels on the file as requested by the label IDs in the `includeLabels` parameter. By default, no labels are returned.
                public init(labels: [Components.Schemas.Label]? = nil) {
                    self.labels = labels
                }
                public enum CodingKeys: String, CodingKey {
                    case labels
                }
            }
            /// Output only. An overview of the labels on the file.
            ///
            /// - Remark: Generated from `#/components/schemas/File/labelInfo`.
            public var labelInfo: Components.Schemas.File.LabelInfoPayload?
            /// - Remark: Generated from `#/components/schemas/File/lastModifyingUser`.
            public var lastModifyingUser: Components.Schemas.User?
            /// Contains details about the link URLs that clients are using to refer to this item.
            ///
            /// - Remark: Generated from `#/components/schemas/File/linkShareMetadata`.
            public struct LinkShareMetadataPayload: Codable, Hashable, Sendable {
                /// Output only. Whether the file is eligible for security update.
                ///
                /// - Remark: Generated from `#/components/schemas/File/linkShareMetadata/securityUpdateEligible`.
                public var securityUpdateEligible: Swift.Bool?
                /// Output only. Whether the security update is enabled for this file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/linkShareMetadata/securityUpdateEnabled`.
                public var securityUpdateEnabled: Swift.Bool?
                /// Creates a new `LinkShareMetadataPayload`.
                ///
                /// - Parameters:
                ///   - securityUpdateEligible: Output only. Whether the file is eligible for security update.
                ///   - securityUpdateEnabled: Output only. Whether the security update is enabled for this file.
                public init(
                    securityUpdateEligible: Swift.Bool? = nil,
                    securityUpdateEnabled: Swift.Bool? = nil
                ) {
                    self.securityUpdateEligible = securityUpdateEligible
                    self.securityUpdateEnabled = securityUpdateEnabled
                }
                public enum CodingKeys: String, CodingKey {
                    case securityUpdateEligible
                    case securityUpdateEnabled
                }
            }
            /// Contains details about the link URLs that clients are using to refer to this item.
            ///
            /// - Remark: Generated from `#/components/schemas/File/linkShareMetadata`.
            public var linkShareMetadata: Components.Schemas.File.LinkShareMetadataPayload?
            /// Output only. The MD5 checksum for the content of the file. This is only applicable to files with binary content in Google Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/File/md5Checksum`.
            public var md5Checksum: Swift.String?
            /// The MIME type of the file. Google Drive attempts to automatically detect an appropriate value from uploaded content, if no value is provided. The value cannot be changed unless a new revision is uploaded. If a file is created with a Google Doc MIME type, the uploaded content is imported, if possible. The supported import formats are published in the About resource.
            ///
            /// - Remark: Generated from `#/components/schemas/File/mimeType`.
            public var mimeType: Swift.String?
            /// Output only. Whether the file has been modified by this user.
            ///
            /// - Remark: Generated from `#/components/schemas/File/modifiedByMe`.
            public var modifiedByMe: Swift.Bool?
            /// The last time the file was modified by the user (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/File/modifiedByMeTime`.
            public var modifiedByMeTime: Foundation.Date?
            /// he last time the file was modified by anyone (RFC 3339 date-time). Note that setting modifiedTime will also update modifiedByMeTime for the user.
            ///
            /// - Remark: Generated from `#/components/schemas/File/modifiedTime`.
            public var modifiedTime: Foundation.Date?
            /// The name of the file. This is not necessarily unique within a folder. Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the name is constant.
            ///
            /// - Remark: Generated from `#/components/schemas/File/name`.
            public var name: Swift.String?
            /// The original filename of the uploaded content if available, or else the original value of the `name` field. This is only available for files with binary content in Google Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/File/originalFilename`.
            public var originalFilename: Swift.String?
            /// Output only. Whether the user owns the file. Not populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/ownedByMe`.
            public var ownedByMe: Swift.Bool?
            /// Output only. The owner of this file. Only certain legacy files may have more than one owner. This field isn't populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/owners`.
            public var owners: [Components.Schemas.User]?
            /// The IDs of the parent folders which contain the file. If not specified as part of a create request, the file is placed directly in the user's My Drive folder. If not specified as part of a copy request, the file inherits any discoverable parents of the source file. Update requests must use the `addParents` and `removeParents` parameters to modify the parents list.
            ///
            /// - Remark: Generated from `#/components/schemas/File/parents`.
            public var parents: [Swift.String]?
            /// Output only. List of permission IDs for users with access to this file.
            ///
            /// - Remark: Generated from `#/components/schemas/File/permissionIds`.
            public var permissionIds: [Swift.String]?
            /// Output only. The full list of permissions for the file. This is only available if the requesting user can share the file. Not populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/permissions`.
            public var permissions: [Components.Schemas.Permission]?
            /// A collection of arbitrary key-value pairs which are visible to all apps.
            /// Entries with null values are cleared in update and copy requests.
            ///
            /// - Remark: Generated from `#/components/schemas/File/properties`.
            public struct PropertiesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `PropertiesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A collection of arbitrary key-value pairs which are visible to all apps.
            /// Entries with null values are cleared in update and copy requests.
            ///
            /// - Remark: Generated from `#/components/schemas/File/properties`.
            public var properties: Components.Schemas.File.PropertiesPayload?
            /// Output only. The number of storage quota bytes used by the file. This includes the head revision as well as previous revisions with `keepForever` enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/File/quotaBytesUsed`.
            public var quotaBytesUsed: Swift.String?
            /// Output only. A key needed to access the item via a shared link.
            ///
            /// - Remark: Generated from `#/components/schemas/File/resourceKey`.
            public var resourceKey: Swift.String?
            /// Output only. The SHA1 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
            ///
            /// - Remark: Generated from `#/components/schemas/File/sha1Checksum`.
            public var sha1Checksum: Swift.String?
            /// Output only. The SHA256 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
            ///
            /// - Remark: Generated from `#/components/schemas/File/sha256Checksum`.
            public var sha256Checksum: Swift.String?
            /// Output only. Whether the file has been shared. Not populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/shared`.
            public var shared: Swift.Bool?
            /// The time at which the file was shared with the user, if applicable (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/File/sharedWithMeTime`.
            public var sharedWithMeTime: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/File/sharingUser`.
            public var sharingUser: Components.Schemas.User?
            /// Shortcut file details. Only populated for shortcut files, which have the mimeType field set to `application/vnd.google-apps.shortcut`.
            ///
            /// - Remark: Generated from `#/components/schemas/File/shortcutDetails`.
            public struct ShortcutDetailsPayload: Codable, Hashable, Sendable {
                /// The ID of the file that this shortcut points to.
                ///
                /// - Remark: Generated from `#/components/schemas/File/shortcutDetails/targetId`.
                public var targetId: Swift.String?
                /// Output only. The MIME type of the file that this shortcut points to. The value of this field is a snapshot of the target's MIME type, captured when the shortcut is created.
                ///
                /// - Remark: Generated from `#/components/schemas/File/shortcutDetails/targetMimeType`.
                public var targetMimeType: Swift.String?
                /// Output only. The ResourceKey for the target file.
                ///
                /// - Remark: Generated from `#/components/schemas/File/shortcutDetails/targetResourceKey`.
                public var targetResourceKey: Swift.String?
                /// Creates a new `ShortcutDetailsPayload`.
                ///
                /// - Parameters:
                ///   - targetId: The ID of the file that this shortcut points to.
                ///   - targetMimeType: Output only. The MIME type of the file that this shortcut points to. The value of this field is a snapshot of the target's MIME type, captured when the shortcut is created.
                ///   - targetResourceKey: Output only. The ResourceKey for the target file.
                public init(
                    targetId: Swift.String? = nil,
                    targetMimeType: Swift.String? = nil,
                    targetResourceKey: Swift.String? = nil
                ) {
                    self.targetId = targetId
                    self.targetMimeType = targetMimeType
                    self.targetResourceKey = targetResourceKey
                }
                public enum CodingKeys: String, CodingKey {
                    case targetId
                    case targetMimeType
                    case targetResourceKey
                }
            }
            /// Shortcut file details. Only populated for shortcut files, which have the mimeType field set to `application/vnd.google-apps.shortcut`.
            ///
            /// - Remark: Generated from `#/components/schemas/File/shortcutDetails`.
            public var shortcutDetails: Components.Schemas.File.ShortcutDetailsPayload?
            /// Output only. Size in bytes of blobs and first party editor files. Won't be populated for files that have no size, like shortcuts and folders.
            ///
            /// - Remark: Generated from `#/components/schemas/File/size`.
            public var size: Swift.String?
            /// Output only. The list of spaces which contain the file. The currently supported values are 'drive', 'appDataFolder' and 'photos'.
            ///
            /// - Remark: Generated from `#/components/schemas/File/spaces`.
            public var spaces: [Swift.String]?
            /// Whether the user has starred the file.
            ///
            /// - Remark: Generated from `#/components/schemas/File/starred`.
            public var starred: Swift.Bool?
            /// Deprecated: Output only. Use `driveId` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/File/teamDriveId`.
            @available(*, deprecated)
            public var teamDriveId: Swift.String?
            /// Output only. A short-lived link to the file's thumbnail, if available. Typically lasts on the order of hours. Only populated when the requesting app can access the file's content. If the file isn't shared publicly, the URL returned in `Files.thumbnailLink` must be fetched using a credentialed request.
            ///
            /// - Remark: Generated from `#/components/schemas/File/thumbnailLink`.
            public var thumbnailLink: Swift.String?
            /// Output only. The thumbnail version for use in thumbnail cache invalidation.
            ///
            /// - Remark: Generated from `#/components/schemas/File/thumbnailVersion`.
            public var thumbnailVersion: Swift.String?
            /// Whether the file has been trashed, either explicitly or from a trashed parent folder. Only the owner may trash a file, and other users cannot see files in the owner's trash.
            ///
            /// - Remark: Generated from `#/components/schemas/File/trashed`.
            public var trashed: Swift.Bool?
            /// The time that the item was trashed (RFC 3339 date-time). Only populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/trashedTime`.
            public var trashedTime: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/File/trashingUser`.
            public var trashingUser: Components.Schemas.User?
            /// Output only. A monotonically increasing version number for the file. This reflects every change made to the file on the server, even those not visible to the user.
            ///
            /// - Remark: Generated from `#/components/schemas/File/version`.
            public var version: Swift.String?
            /// Output only. Additional metadata about video media. This may not be available immediately upon upload.
            ///
            /// - Remark: Generated from `#/components/schemas/File/videoMediaMetadata`.
            public struct VideoMediaMetadataPayload: Codable, Hashable, Sendable {
                /// Output only. The duration of the video in milliseconds.
                ///
                /// - Remark: Generated from `#/components/schemas/File/videoMediaMetadata/durationMillis`.
                public var durationMillis: Swift.String?
                /// Output only. The height of the video in pixels.
                ///
                /// - Remark: Generated from `#/components/schemas/File/videoMediaMetadata/height`.
                public var height: Swift.Int32?
                /// Output only. The width of the video in pixels.
                ///
                /// - Remark: Generated from `#/components/schemas/File/videoMediaMetadata/width`.
                public var width: Swift.Int32?
                /// Creates a new `VideoMediaMetadataPayload`.
                ///
                /// - Parameters:
                ///   - durationMillis: Output only. The duration of the video in milliseconds.
                ///   - height: Output only. The height of the video in pixels.
                ///   - width: Output only. The width of the video in pixels.
                public init(
                    durationMillis: Swift.String? = nil,
                    height: Swift.Int32? = nil,
                    width: Swift.Int32? = nil
                ) {
                    self.durationMillis = durationMillis
                    self.height = height
                    self.width = width
                }
                public enum CodingKeys: String, CodingKey {
                    case durationMillis
                    case height
                    case width
                }
            }
            /// Output only. Additional metadata about video media. This may not be available immediately upon upload.
            ///
            /// - Remark: Generated from `#/components/schemas/File/videoMediaMetadata`.
            public var videoMediaMetadata: Components.Schemas.File.VideoMediaMetadataPayload?
            /// Output only. Whether the file has been viewed by this user.
            ///
            /// - Remark: Generated from `#/components/schemas/File/viewedByMe`.
            public var viewedByMe: Swift.Bool?
            /// The last time the file was viewed by the user (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/File/viewedByMeTime`.
            public var viewedByMeTime: Foundation.Date?
            /// Deprecated: Use `copyRequiresWriterPermission` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/File/viewersCanCopyContent`.
            @available(*, deprecated)
            public var viewersCanCopyContent: Swift.Bool?
            /// Output only. A link for downloading the content of the file in a browser. This is only available for files with binary content in Google Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/File/webContentLink`.
            public var webContentLink: Swift.String?
            /// Output only. A link for opening the file in a relevant Google editor or viewer in a browser.
            ///
            /// - Remark: Generated from `#/components/schemas/File/webViewLink`.
            public var webViewLink: Swift.String?
            /// Whether users with only `writer` permission can modify the file's permissions. Not populated for items in shared drives.
            ///
            /// - Remark: Generated from `#/components/schemas/File/writersCanShare`.
            public var writersCanShare: Swift.Bool?
            /// Creates a new `File`.
            ///
            /// - Parameters:
            ///   - appProperties: A collection of arbitrary key-value pairs which are private to the requesting app.
            ///   - capabilities: Output only. Capabilities the current user has on this file. Each capability corresponds to a fine-grained action that a user may take.
            ///   - contentHints: Additional information about the content of the file. These fields are never populated in responses.
            ///   - contentRestrictions: Restrictions for accessing the content of the file. Only populated if such a restriction exists.
            ///   - copyRequiresWriterPermission: Whether the options to copy, print, or download this file, should be disabled for readers and commenters.
            ///   - createdTime: The time at which the file was created (RFC 3339 date-time).
            ///   - description: A short description of the file.
            ///   - driveId: Output only. ID of the shared drive the file resides in. Only populated for items in shared drives.
            ///   - explicitlyTrashed: Output only. Whether the file has been explicitly trashed, as opposed to recursively trashed from a parent folder.
            ///   - exportLinks: Output only. Links for exporting Docs Editors files to specific formats.
            ///   - fileExtension: Output only. The final component of `fullFileExtension`. This is only available for files with binary content in Google Drive.
            ///   - folderColorRgb: The color for a folder or a shortcut to a folder as an RGB hex string. The supported colors are published in the `folderColorPalette` field of the About resource. If an unsupported color is specified, the closest color in the palette is used instead.
            ///   - fullFileExtension: Output only. The full file extension extracted from the `name` field. May contain multiple concatenated extensions, such as "tar.gz". This is only available for files with binary content in Google Drive. This is automatically updated when the `name` field changes, however it is not cleared if the new name does not contain a valid extension.
            ///   - hasAugmentedPermissions: Output only. Whether there are permissions directly on this file. This field is only populated for items in shared drives.
            ///   - hasThumbnail: Output only. Whether this file has a thumbnail. This does not indicate whether the requesting app has access to the thumbnail. To check access, look for the presence of the thumbnailLink field.
            ///   - headRevisionId: Output only. The ID of the file's head revision. This is currently only available for files with binary content in Google Drive.
            ///   - iconLink: Output only. A static, unauthenticated link to the file's icon.
            ///   - id: The ID of the file.
            ///   - imageMediaMetadata: Output only. Additional metadata about image media, if available.
            ///   - isAppAuthorized: Output only. Whether the file was created or opened by the requesting app.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#file"`.
            ///   - labelInfo: Output only. An overview of the labels on the file.
            ///   - lastModifyingUser:
            ///   - linkShareMetadata: Contains details about the link URLs that clients are using to refer to this item.
            ///   - md5Checksum: Output only. The MD5 checksum for the content of the file. This is only applicable to files with binary content in Google Drive.
            ///   - mimeType: The MIME type of the file. Google Drive attempts to automatically detect an appropriate value from uploaded content, if no value is provided. The value cannot be changed unless a new revision is uploaded. If a file is created with a Google Doc MIME type, the uploaded content is imported, if possible. The supported import formats are published in the About resource.
            ///   - modifiedByMe: Output only. Whether the file has been modified by this user.
            ///   - modifiedByMeTime: The last time the file was modified by the user (RFC 3339 date-time).
            ///   - modifiedTime: he last time the file was modified by anyone (RFC 3339 date-time). Note that setting modifiedTime will also update modifiedByMeTime for the user.
            ///   - name: The name of the file. This is not necessarily unique within a folder. Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the name is constant.
            ///   - originalFilename: The original filename of the uploaded content if available, or else the original value of the `name` field. This is only available for files with binary content in Google Drive.
            ///   - ownedByMe: Output only. Whether the user owns the file. Not populated for items in shared drives.
            ///   - owners: Output only. The owner of this file. Only certain legacy files may have more than one owner. This field isn't populated for items in shared drives.
            ///   - parents: The IDs of the parent folders which contain the file. If not specified as part of a create request, the file is placed directly in the user's My Drive folder. If not specified as part of a copy request, the file inherits any discoverable parents of the source file. Update requests must use the `addParents` and `removeParents` parameters to modify the parents list.
            ///   - permissionIds: Output only. List of permission IDs for users with access to this file.
            ///   - permissions: Output only. The full list of permissions for the file. This is only available if the requesting user can share the file. Not populated for items in shared drives.
            ///   - properties: A collection of arbitrary key-value pairs which are visible to all apps.
            ///   - quotaBytesUsed: Output only. The number of storage quota bytes used by the file. This includes the head revision as well as previous revisions with `keepForever` enabled.
            ///   - resourceKey: Output only. A key needed to access the item via a shared link.
            ///   - sha1Checksum: Output only. The SHA1 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
            ///   - sha256Checksum: Output only. The SHA256 checksum associated with this file, if available. This field is only populated for files with content stored in Google Drive; it is not populated for Docs Editors or shortcut files.
            ///   - shared: Output only. Whether the file has been shared. Not populated for items in shared drives.
            ///   - sharedWithMeTime: The time at which the file was shared with the user, if applicable (RFC 3339 date-time).
            ///   - sharingUser:
            ///   - shortcutDetails: Shortcut file details. Only populated for shortcut files, which have the mimeType field set to `application/vnd.google-apps.shortcut`.
            ///   - size: Output only. Size in bytes of blobs and first party editor files. Won't be populated for files that have no size, like shortcuts and folders.
            ///   - spaces: Output only. The list of spaces which contain the file. The currently supported values are 'drive', 'appDataFolder' and 'photos'.
            ///   - starred: Whether the user has starred the file.
            ///   - teamDriveId: Deprecated: Output only. Use `driveId` instead.
            ///   - thumbnailLink: Output only. A short-lived link to the file's thumbnail, if available. Typically lasts on the order of hours. Only populated when the requesting app can access the file's content. If the file isn't shared publicly, the URL returned in `Files.thumbnailLink` must be fetched using a credentialed request.
            ///   - thumbnailVersion: Output only. The thumbnail version for use in thumbnail cache invalidation.
            ///   - trashed: Whether the file has been trashed, either explicitly or from a trashed parent folder. Only the owner may trash a file, and other users cannot see files in the owner's trash.
            ///   - trashedTime: The time that the item was trashed (RFC 3339 date-time). Only populated for items in shared drives.
            ///   - trashingUser:
            ///   - version: Output only. A monotonically increasing version number for the file. This reflects every change made to the file on the server, even those not visible to the user.
            ///   - videoMediaMetadata: Output only. Additional metadata about video media. This may not be available immediately upon upload.
            ///   - viewedByMe: Output only. Whether the file has been viewed by this user.
            ///   - viewedByMeTime: The last time the file was viewed by the user (RFC 3339 date-time).
            ///   - viewersCanCopyContent: Deprecated: Use `copyRequiresWriterPermission` instead.
            ///   - webContentLink: Output only. A link for downloading the content of the file in a browser. This is only available for files with binary content in Google Drive.
            ///   - webViewLink: Output only. A link for opening the file in a relevant Google editor or viewer in a browser.
            ///   - writersCanShare: Whether users with only `writer` permission can modify the file's permissions. Not populated for items in shared drives.
            public init(
                appProperties: Components.Schemas.File.AppPropertiesPayload? = nil,
                capabilities: Components.Schemas.File.CapabilitiesPayload? = nil,
                contentHints: Components.Schemas.File.ContentHintsPayload? = nil,
                contentRestrictions: [Components.Schemas.ContentRestriction]? = nil,
                copyRequiresWriterPermission: Swift.Bool? = nil,
                createdTime: Foundation.Date? = nil,
                description: Swift.String? = nil,
                driveId: Swift.String? = nil,
                explicitlyTrashed: Swift.Bool? = nil,
                exportLinks: Components.Schemas.File.ExportLinksPayload? = nil,
                fileExtension: Swift.String? = nil,
                folderColorRgb: Swift.String? = nil,
                fullFileExtension: Swift.String? = nil,
                hasAugmentedPermissions: Swift.Bool? = nil,
                hasThumbnail: Swift.Bool? = nil,
                headRevisionId: Swift.String? = nil,
                iconLink: Swift.String? = nil,
                id: Swift.String? = nil,
                imageMediaMetadata: Components.Schemas.File.ImageMediaMetadataPayload? = nil,
                isAppAuthorized: Swift.Bool? = nil,
                kind: Swift.String? = nil,
                labelInfo: Components.Schemas.File.LabelInfoPayload? = nil,
                lastModifyingUser: Components.Schemas.User? = nil,
                linkShareMetadata: Components.Schemas.File.LinkShareMetadataPayload? = nil,
                md5Checksum: Swift.String? = nil,
                mimeType: Swift.String? = nil,
                modifiedByMe: Swift.Bool? = nil,
                modifiedByMeTime: Foundation.Date? = nil,
                modifiedTime: Foundation.Date? = nil,
                name: Swift.String? = nil,
                originalFilename: Swift.String? = nil,
                ownedByMe: Swift.Bool? = nil,
                owners: [Components.Schemas.User]? = nil,
                parents: [Swift.String]? = nil,
                permissionIds: [Swift.String]? = nil,
                permissions: [Components.Schemas.Permission]? = nil,
                properties: Components.Schemas.File.PropertiesPayload? = nil,
                quotaBytesUsed: Swift.String? = nil,
                resourceKey: Swift.String? = nil,
                sha1Checksum: Swift.String? = nil,
                sha256Checksum: Swift.String? = nil,
                shared: Swift.Bool? = nil,
                sharedWithMeTime: Foundation.Date? = nil,
                sharingUser: Components.Schemas.User? = nil,
                shortcutDetails: Components.Schemas.File.ShortcutDetailsPayload? = nil,
                size: Swift.String? = nil,
                spaces: [Swift.String]? = nil,
                starred: Swift.Bool? = nil,
                teamDriveId: Swift.String? = nil,
                thumbnailLink: Swift.String? = nil,
                thumbnailVersion: Swift.String? = nil,
                trashed: Swift.Bool? = nil,
                trashedTime: Foundation.Date? = nil,
                trashingUser: Components.Schemas.User? = nil,
                version: Swift.String? = nil,
                videoMediaMetadata: Components.Schemas.File.VideoMediaMetadataPayload? = nil,
                viewedByMe: Swift.Bool? = nil,
                viewedByMeTime: Foundation.Date? = nil,
                viewersCanCopyContent: Swift.Bool? = nil,
                webContentLink: Swift.String? = nil,
                webViewLink: Swift.String? = nil,
                writersCanShare: Swift.Bool? = nil
            ) {
                self.appProperties = appProperties
                self.capabilities = capabilities
                self.contentHints = contentHints
                self.contentRestrictions = contentRestrictions
                self.copyRequiresWriterPermission = copyRequiresWriterPermission
                self.createdTime = createdTime
                self.description = description
                self.driveId = driveId
                self.explicitlyTrashed = explicitlyTrashed
                self.exportLinks = exportLinks
                self.fileExtension = fileExtension
                self.folderColorRgb = folderColorRgb
                self.fullFileExtension = fullFileExtension
                self.hasAugmentedPermissions = hasAugmentedPermissions
                self.hasThumbnail = hasThumbnail
                self.headRevisionId = headRevisionId
                self.iconLink = iconLink
                self.id = id
                self.imageMediaMetadata = imageMediaMetadata
                self.isAppAuthorized = isAppAuthorized
                self.kind = kind
                self.labelInfo = labelInfo
                self.lastModifyingUser = lastModifyingUser
                self.linkShareMetadata = linkShareMetadata
                self.md5Checksum = md5Checksum
                self.mimeType = mimeType
                self.modifiedByMe = modifiedByMe
                self.modifiedByMeTime = modifiedByMeTime
                self.modifiedTime = modifiedTime
                self.name = name
                self.originalFilename = originalFilename
                self.ownedByMe = ownedByMe
                self.owners = owners
                self.parents = parents
                self.permissionIds = permissionIds
                self.permissions = permissions
                self.properties = properties
                self.quotaBytesUsed = quotaBytesUsed
                self.resourceKey = resourceKey
                self.sha1Checksum = sha1Checksum
                self.sha256Checksum = sha256Checksum
                self.shared = shared
                self.sharedWithMeTime = sharedWithMeTime
                self.sharingUser = sharingUser
                self.shortcutDetails = shortcutDetails
                self.size = size
                self.spaces = spaces
                self.starred = starred
                self.teamDriveId = teamDriveId
                self.thumbnailLink = thumbnailLink
                self.thumbnailVersion = thumbnailVersion
                self.trashed = trashed
                self.trashedTime = trashedTime
                self.trashingUser = trashingUser
                self.version = version
                self.videoMediaMetadata = videoMediaMetadata
                self.viewedByMe = viewedByMe
                self.viewedByMeTime = viewedByMeTime
                self.viewersCanCopyContent = viewersCanCopyContent
                self.webContentLink = webContentLink
                self.webViewLink = webViewLink
                self.writersCanShare = writersCanShare
            }
            public enum CodingKeys: String, CodingKey {
                case appProperties
                case capabilities
                case contentHints
                case contentRestrictions
                case copyRequiresWriterPermission
                case createdTime
                case description
                case driveId
                case explicitlyTrashed
                case exportLinks
                case fileExtension
                case folderColorRgb
                case fullFileExtension
                case hasAugmentedPermissions
                case hasThumbnail
                case headRevisionId
                case iconLink
                case id
                case imageMediaMetadata
                case isAppAuthorized
                case kind
                case labelInfo
                case lastModifyingUser
                case linkShareMetadata
                case md5Checksum
                case mimeType
                case modifiedByMe
                case modifiedByMeTime
                case modifiedTime
                case name
                case originalFilename
                case ownedByMe
                case owners
                case parents
                case permissionIds
                case permissions
                case properties
                case quotaBytesUsed
                case resourceKey
                case sha1Checksum
                case sha256Checksum
                case shared
                case sharedWithMeTime
                case sharingUser
                case shortcutDetails
                case size
                case spaces
                case starred
                case teamDriveId
                case thumbnailLink
                case thumbnailVersion
                case trashed
                case trashedTime
                case trashingUser
                case version
                case videoMediaMetadata
                case viewedByMe
                case viewedByMeTime
                case viewersCanCopyContent
                case webContentLink
                case webViewLink
                case writersCanShare
            }
        }
        /// A list of files.
        ///
        /// - Remark: Generated from `#/components/schemas/FileList`.
        public struct FileList: Codable, Hashable, Sendable {
            /// The list of files. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/FileList/files`.
            public var files: [Components.Schemas.File]?
            /// Whether the search process was incomplete. If true, then some search results might be missing, since all documents were not searched. This can occur when searching multiple drives with the 'allDrives' corpora, but all corpora couldn't be searched. When this happens, it's suggested that clients narrow their query by choosing a different corpus such as 'user' or 'drive'.
            ///
            /// - Remark: Generated from `#/components/schemas/FileList/incompleteSearch`.
            public var incompleteSearch: Swift.Bool?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#fileList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/FileList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of files. This will be absent if the end of the files list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/FileList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// Creates a new `FileList`.
            ///
            /// - Parameters:
            ///   - files: The list of files. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///   - incompleteSearch: Whether the search process was incomplete. If true, then some search results might be missing, since all documents were not searched. This can occur when searching multiple drives with the 'allDrives' corpora, but all corpora couldn't be searched. When this happens, it's suggested that clients narrow their query by choosing a different corpus such as 'user' or 'drive'.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#fileList"`.
            ///   - nextPageToken: The page token for the next page of files. This will be absent if the end of the files list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            public init(
                files: [Components.Schemas.File]? = nil,
                incompleteSearch: Swift.Bool? = nil,
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil
            ) {
                self.files = files
                self.incompleteSearch = incompleteSearch
                self.kind = kind
                self.nextPageToken = nextPageToken
            }
            public enum CodingKeys: String, CodingKey {
                case files
                case incompleteSearch
                case kind
                case nextPageToken
            }
        }
        /// A list of generated file IDs which can be provided in create requests.
        ///
        /// - Remark: Generated from `#/components/schemas/GeneratedIds`.
        public struct GeneratedIds: Codable, Hashable, Sendable {
            /// The IDs generated for the requesting user in the specified space.
            ///
            /// - Remark: Generated from `#/components/schemas/GeneratedIds/ids`.
            public var ids: [Swift.String]?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#generatedIds"`.
            ///
            /// - Remark: Generated from `#/components/schemas/GeneratedIds/kind`.
            public var kind: Swift.String?
            /// The type of file that can be created with these IDs.
            ///
            /// - Remark: Generated from `#/components/schemas/GeneratedIds/space`.
            public var space: Swift.String?
            /// Creates a new `GeneratedIds`.
            ///
            /// - Parameters:
            ///   - ids: The IDs generated for the requesting user in the specified space.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#generatedIds"`.
            ///   - space: The type of file that can be created with these IDs.
            public init(
                ids: [Swift.String]? = nil,
                kind: Swift.String? = nil,
                space: Swift.String? = nil
            ) {
                self.ids = ids
                self.kind = kind
                self.space = space
            }
            public enum CodingKeys: String, CodingKey {
                case ids
                case kind
                case space
            }
        }
        /// Representation of label and label fields.
        ///
        /// - Remark: Generated from `#/components/schemas/Label`.
        public struct Label: Codable, Hashable, Sendable {
            /// A map of the fields on the label, keyed by the field's ID.
            ///
            /// - Remark: Generated from `#/components/schemas/Label/fields`.
            public struct FieldsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.LabelField]
                /// Creates a new `FieldsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.LabelField] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// A map of the fields on the label, keyed by the field's ID.
            ///
            /// - Remark: Generated from `#/components/schemas/Label/fields`.
            public var fields: Components.Schemas.Label.FieldsPayload?
            /// The ID of the label.
            ///
            /// - Remark: Generated from `#/components/schemas/Label/id`.
            public var id: Swift.String?
            /// This is always drive#label
            ///
            /// - Remark: Generated from `#/components/schemas/Label/kind`.
            public var kind: Swift.String?
            /// The revision ID of the label.
            ///
            /// - Remark: Generated from `#/components/schemas/Label/revisionId`.
            public var revisionId: Swift.String?
            /// Creates a new `Label`.
            ///
            /// - Parameters:
            ///   - fields: A map of the fields on the label, keyed by the field's ID.
            ///   - id: The ID of the label.
            ///   - kind: This is always drive#label
            ///   - revisionId: The revision ID of the label.
            public init(
                fields: Components.Schemas.Label.FieldsPayload? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                revisionId: Swift.String? = nil
            ) {
                self.fields = fields
                self.id = id
                self.kind = kind
                self.revisionId = revisionId
            }
            public enum CodingKeys: String, CodingKey {
                case fields
                case id
                case kind
                case revisionId
            }
        }
        /// Representation of field, which is a typed key-value pair.
        ///
        /// - Remark: Generated from `#/components/schemas/LabelField`.
        public struct LabelField: Codable, Hashable, Sendable {
            /// Only present if valueType is dateString. RFC 3339 formatted date: YYYY-MM-DD.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/dateString`.
            public var dateString: [Swift.String]?
            /// The identifier of this label field.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/id`.
            public var id: Swift.String?
            /// Only present if `valueType` is `integer`.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/integer`.
            public var integer: [Swift.String]?
            /// This is always drive#labelField.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/kind`.
            public var kind: Swift.String?
            /// Only present if `valueType` is `selection`
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/selection`.
            public var selection: [Swift.String]?
            /// Only present if `valueType` is `text`.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/text`.
            public var text: [Swift.String]?
            /// Only present if `valueType` is `user`.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/user`.
            public var user: [Components.Schemas.User]?
            /// The field type. While new values may be supported in the future, the following are currently allowed: * `dateString` * `integer` * `selection` * `text` * `user`
            ///
            /// - Remark: Generated from `#/components/schemas/LabelField/valueType`.
            public var valueType: Swift.String?
            /// Creates a new `LabelField`.
            ///
            /// - Parameters:
            ///   - dateString: Only present if valueType is dateString. RFC 3339 formatted date: YYYY-MM-DD.
            ///   - id: The identifier of this label field.
            ///   - integer: Only present if `valueType` is `integer`.
            ///   - kind: This is always drive#labelField.
            ///   - selection: Only present if `valueType` is `selection`
            ///   - text: Only present if `valueType` is `text`.
            ///   - user: Only present if `valueType` is `user`.
            ///   - valueType: The field type. While new values may be supported in the future, the following are currently allowed: * `dateString` * `integer` * `selection` * `text` * `user`
            public init(
                dateString: [Swift.String]? = nil,
                id: Swift.String? = nil,
                integer: [Swift.String]? = nil,
                kind: Swift.String? = nil,
                selection: [Swift.String]? = nil,
                text: [Swift.String]? = nil,
                user: [Components.Schemas.User]? = nil,
                valueType: Swift.String? = nil
            ) {
                self.dateString = dateString
                self.id = id
                self.integer = integer
                self.kind = kind
                self.selection = selection
                self.text = text
                self.user = user
                self.valueType = valueType
            }
            public enum CodingKeys: String, CodingKey {
                case dateString
                case id
                case integer
                case kind
                case selection
                case text
                case user
                case valueType
            }
        }
        /// A modification to a label's field.
        ///
        /// - Remark: Generated from `#/components/schemas/LabelFieldModification`.
        public struct LabelFieldModification: Codable, Hashable, Sendable {
            /// The ID of the field to be modified.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/fieldId`.
            public var fieldId: Swift.String?
            /// This is always drive#labelFieldModification.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/kind`.
            public var kind: Swift.String?
            /// Replaces the value of a dateString Field with these new values. The string must be in the RFC 3339 full-date format: YYYY-MM-DD.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/setDateValues`.
            public var setDateValues: [Swift.String]?
            /// Replaces the value of an `integer` field with these new values.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/setIntegerValues`.
            public var setIntegerValues: [Swift.String]?
            /// Replaces a `selection` field with these new values.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/setSelectionValues`.
            public var setSelectionValues: [Swift.String]?
            /// Sets the value of a `text` field.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/setTextValues`.
            public var setTextValues: [Swift.String]?
            /// Replaces a `user` field with these new values. The values must be valid email addresses.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/setUserValues`.
            public var setUserValues: [Swift.String]?
            /// Unsets the values for this field.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelFieldModification/unsetValues`.
            public var unsetValues: Swift.Bool?
            /// Creates a new `LabelFieldModification`.
            ///
            /// - Parameters:
            ///   - fieldId: The ID of the field to be modified.
            ///   - kind: This is always drive#labelFieldModification.
            ///   - setDateValues: Replaces the value of a dateString Field with these new values. The string must be in the RFC 3339 full-date format: YYYY-MM-DD.
            ///   - setIntegerValues: Replaces the value of an `integer` field with these new values.
            ///   - setSelectionValues: Replaces a `selection` field with these new values.
            ///   - setTextValues: Sets the value of a `text` field.
            ///   - setUserValues: Replaces a `user` field with these new values. The values must be valid email addresses.
            ///   - unsetValues: Unsets the values for this field.
            public init(
                fieldId: Swift.String? = nil,
                kind: Swift.String? = nil,
                setDateValues: [Swift.String]? = nil,
                setIntegerValues: [Swift.String]? = nil,
                setSelectionValues: [Swift.String]? = nil,
                setTextValues: [Swift.String]? = nil,
                setUserValues: [Swift.String]? = nil,
                unsetValues: Swift.Bool? = nil
            ) {
                self.fieldId = fieldId
                self.kind = kind
                self.setDateValues = setDateValues
                self.setIntegerValues = setIntegerValues
                self.setSelectionValues = setSelectionValues
                self.setTextValues = setTextValues
                self.setUserValues = setUserValues
                self.unsetValues = unsetValues
            }
            public enum CodingKeys: String, CodingKey {
                case fieldId
                case kind
                case setDateValues
                case setIntegerValues
                case setSelectionValues
                case setTextValues
                case setUserValues
                case unsetValues
            }
        }
        /// A list of labels applied to a file.
        ///
        /// - Remark: Generated from `#/components/schemas/LabelList`.
        public struct LabelList: Codable, Hashable, Sendable {
            /// This is always drive#labelList
            ///
            /// - Remark: Generated from `#/components/schemas/LabelList/kind`.
            public var kind: Swift.String?
            /// The list of labels.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelList/labels`.
            public var labels: [Components.Schemas.Label]?
            /// The page token for the next page of labels. This field will be absent if the end of the list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// Creates a new `LabelList`.
            ///
            /// - Parameters:
            ///   - kind: This is always drive#labelList
            ///   - labels: The list of labels.
            ///   - nextPageToken: The page token for the next page of labels. This field will be absent if the end of the list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            public init(
                kind: Swift.String? = nil,
                labels: [Components.Schemas.Label]? = nil,
                nextPageToken: Swift.String? = nil
            ) {
                self.kind = kind
                self.labels = labels
                self.nextPageToken = nextPageToken
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case labels
                case nextPageToken
            }
        }
        /// A modification to a label on a file. A LabelModification can be used to apply a label to a file, update an existing label on a file, or remove a label from a file.
        ///
        /// - Remark: Generated from `#/components/schemas/LabelModification`.
        public struct LabelModification: Codable, Hashable, Sendable {
            /// The list of modifications to this label's fields.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelModification/fieldModifications`.
            public var fieldModifications: [Components.Schemas.LabelFieldModification]?
            /// This is always drive#labelModification.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelModification/kind`.
            public var kind: Swift.String?
            /// The ID of the label to modify.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelModification/labelId`.
            public var labelId: Swift.String?
            /// If true, the label will be removed from the file.
            ///
            /// - Remark: Generated from `#/components/schemas/LabelModification/removeLabel`.
            public var removeLabel: Swift.Bool?
            /// Creates a new `LabelModification`.
            ///
            /// - Parameters:
            ///   - fieldModifications: The list of modifications to this label's fields.
            ///   - kind: This is always drive#labelModification.
            ///   - labelId: The ID of the label to modify.
            ///   - removeLabel: If true, the label will be removed from the file.
            public init(
                fieldModifications: [Components.Schemas.LabelFieldModification]? = nil,
                kind: Swift.String? = nil,
                labelId: Swift.String? = nil,
                removeLabel: Swift.Bool? = nil
            ) {
                self.fieldModifications = fieldModifications
                self.kind = kind
                self.labelId = labelId
                self.removeLabel = removeLabel
            }
            public enum CodingKeys: String, CodingKey {
                case fieldModifications
                case kind
                case labelId
                case removeLabel
            }
        }
        /// A request to modify the set of labels on a file. This request may contain many modifications that will either all succeed or all fail atomically.
        ///
        /// - Remark: Generated from `#/components/schemas/ModifyLabelsRequest`.
        public struct ModifyLabelsRequest: Codable, Hashable, Sendable {
            /// This is always drive#modifyLabelsRequest.
            ///
            /// - Remark: Generated from `#/components/schemas/ModifyLabelsRequest/kind`.
            public var kind: Swift.String?
            /// The list of modifications to apply to the labels on the file.
            ///
            /// - Remark: Generated from `#/components/schemas/ModifyLabelsRequest/labelModifications`.
            public var labelModifications: [Components.Schemas.LabelModification]?
            /// Creates a new `ModifyLabelsRequest`.
            ///
            /// - Parameters:
            ///   - kind: This is always drive#modifyLabelsRequest.
            ///   - labelModifications: The list of modifications to apply to the labels on the file.
            public init(
                kind: Swift.String? = nil,
                labelModifications: [Components.Schemas.LabelModification]? = nil
            ) {
                self.kind = kind
                self.labelModifications = labelModifications
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case labelModifications
            }
        }
        /// Response to a ModifyLabels request. This contains only those labels which were added or updated by the request.
        ///
        /// - Remark: Generated from `#/components/schemas/ModifyLabelsResponse`.
        public struct ModifyLabelsResponse: Codable, Hashable, Sendable {
            /// This is always drive#modifyLabelsResponse
            ///
            /// - Remark: Generated from `#/components/schemas/ModifyLabelsResponse/kind`.
            public var kind: Swift.String?
            /// The list of labels which were added or updated by the request.
            ///
            /// - Remark: Generated from `#/components/schemas/ModifyLabelsResponse/modifiedLabels`.
            public var modifiedLabels: [Components.Schemas.Label]?
            /// Creates a new `ModifyLabelsResponse`.
            ///
            /// - Parameters:
            ///   - kind: This is always drive#modifyLabelsResponse
            ///   - modifiedLabels: The list of labels which were added or updated by the request.
            public init(
                kind: Swift.String? = nil,
                modifiedLabels: [Components.Schemas.Label]? = nil
            ) {
                self.kind = kind
                self.modifiedLabels = modifiedLabels
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case modifiedLabels
            }
        }
        /// A permission for a file. A permission grants a user, group, domain, or the world access to a file or a folder hierarchy. Some resource methods (such as `permissions.update`) require a `permissionId`. Use the `permissions.list` method to retrieve the ID for a file, folder, or shared drive.
        ///
        /// - Remark: Generated from `#/components/schemas/Permission`.
        public struct Permission: Codable, Hashable, Sendable {
            /// Whether the permission allows the file to be discovered through search. This is only applicable for permissions of type `domain` or `anyone`.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/allowFileDiscovery`.
            public var allowFileDiscovery: Swift.Bool?
            /// Output only. Whether the account associated with this permission has been deleted. This field only pertains to user and group permissions.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/deleted`.
            public var deleted: Swift.Bool?
            /// Output only. The "pretty" name of the value of the permission. The following is a list of examples for each type of permission: * `user` - User's full name, as defined for their Google account, such as "Joe Smith." * `group` - Name of the Google Group, such as "The Company Administrators." * `domain` - String domain name, such as "thecompany.com." * `anyone` - No `displayName` is present.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/displayName`.
            public var displayName: Swift.String?
            /// The domain to which this permission refers.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/domain`.
            public var domain: Swift.String?
            /// The email address of the user or group to which this permission refers.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/emailAddress`.
            public var emailAddress: Swift.String?
            /// The time at which this permission will expire (RFC 3339 date-time). Expiration times have the following restrictions: - They can only be set on user and group permissions - The time must be in the future - The time cannot be more than a year in the future
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/expirationTime`.
            public var expirationTime: Foundation.Date?
            /// Output only. The ID of this permission. This is a unique identifier for the grantee, and is published in User resources as `permissionId`. IDs should be treated as opaque values.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/id`.
            public var id: Swift.String?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#permission"`.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/kind`.
            public var kind: Swift.String?
            /// Whether the account associated with this permission is a pending owner. Only populated for `user` type permissions for files that are not in a shared drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/pendingOwner`.
            public var pendingOwner: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/Permission/PermissionDetailsPayload`.
            public struct PermissionDetailsPayloadPayload: Codable, Hashable, Sendable {
                /// Output only. Whether this permission is inherited. This field is always populated. This is an output-only field.
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/PermissionDetailsPayload/inherited`.
                public var inherited: Swift.Bool?
                /// Output only. The ID of the item from which this permission is inherited. This is an output-only field.
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/PermissionDetailsPayload/inheritedFrom`.
                public var inheritedFrom: Swift.String?
                /// Output only. The permission type for this user. While new values may be added in future, the following are currently possible: * `file` * `member`
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/PermissionDetailsPayload/permissionType`.
                public var permissionType: Swift.String?
                /// Output only. The primary role for this user. While new values may be added in the future, the following are currently possible: * `organizer` * `fileOrganizer` * `writer` * `commenter` * `reader`
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/PermissionDetailsPayload/role`.
                public var role: Swift.String?
                /// Creates a new `PermissionDetailsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - inherited: Output only. Whether this permission is inherited. This field is always populated. This is an output-only field.
                ///   - inheritedFrom: Output only. The ID of the item from which this permission is inherited. This is an output-only field.
                ///   - permissionType: Output only. The permission type for this user. While new values may be added in future, the following are currently possible: * `file` * `member`
                ///   - role: Output only. The primary role for this user. While new values may be added in the future, the following are currently possible: * `organizer` * `fileOrganizer` * `writer` * `commenter` * `reader`
                public init(
                    inherited: Swift.Bool? = nil,
                    inheritedFrom: Swift.String? = nil,
                    permissionType: Swift.String? = nil,
                    role: Swift.String? = nil
                ) {
                    self.inherited = inherited
                    self.inheritedFrom = inheritedFrom
                    self.permissionType = permissionType
                    self.role = role
                }
                public enum CodingKeys: String, CodingKey {
                    case inherited
                    case inheritedFrom
                    case permissionType
                    case role
                }
            }
            /// Output only. Details of whether the permissions on this shared drive item are inherited or directly on this item. This is an output-only field which is present only for shared drive items.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/permissionDetails`.
            public typealias PermissionDetailsPayload = [Components.Schemas.Permission.PermissionDetailsPayloadPayload]
            /// Output only. Details of whether the permissions on this shared drive item are inherited or directly on this item. This is an output-only field which is present only for shared drive items.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/permissionDetails`.
            public var permissionDetails: Components.Schemas.Permission.PermissionDetailsPayload?
            /// Output only. A link to the user's profile photo, if available.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/photoLink`.
            public var photoLink: Swift.String?
            /// The role granted by this permission. While new values may be supported in the future, the following are currently allowed: * `owner` * `organizer` * `fileOrganizer` * `writer` * `commenter` * `reader`
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/role`.
            public var role: Swift.String?
            /// - Remark: Generated from `#/components/schemas/Permission/TeamDrivePermissionDetailsPayload`.
            public struct TeamDrivePermissionDetailsPayloadPayload: Codable, Hashable, Sendable {
                /// Deprecated: Output only. Use `permissionDetails/inherited` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/TeamDrivePermissionDetailsPayload/inherited`.
                @available(*, deprecated)
                public var inherited: Swift.Bool?
                /// Deprecated: Output only. Use `permissionDetails/inheritedFrom` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/TeamDrivePermissionDetailsPayload/inheritedFrom`.
                @available(*, deprecated)
                public var inheritedFrom: Swift.String?
                /// Deprecated: Output only. Use `permissionDetails/role` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/TeamDrivePermissionDetailsPayload/role`.
                @available(*, deprecated)
                public var role: Swift.String?
                /// Deprecated: Output only. Use `permissionDetails/permissionType` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/Permission/TeamDrivePermissionDetailsPayload/teamDrivePermissionType`.
                @available(*, deprecated)
                public var teamDrivePermissionType: Swift.String?
                /// Creates a new `TeamDrivePermissionDetailsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - inherited: Deprecated: Output only. Use `permissionDetails/inherited` instead.
                ///   - inheritedFrom: Deprecated: Output only. Use `permissionDetails/inheritedFrom` instead.
                ///   - role: Deprecated: Output only. Use `permissionDetails/role` instead.
                ///   - teamDrivePermissionType: Deprecated: Output only. Use `permissionDetails/permissionType` instead.
                public init(
                    inherited: Swift.Bool? = nil,
                    inheritedFrom: Swift.String? = nil,
                    role: Swift.String? = nil,
                    teamDrivePermissionType: Swift.String? = nil
                ) {
                    self.inherited = inherited
                    self.inheritedFrom = inheritedFrom
                    self.role = role
                    self.teamDrivePermissionType = teamDrivePermissionType
                }
                public enum CodingKeys: String, CodingKey {
                    case inherited
                    case inheritedFrom
                    case role
                    case teamDrivePermissionType
                }
            }
            /// Output only. Deprecated: Output only. Use `permissionDetails` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/teamDrivePermissionDetails`.
            public typealias TeamDrivePermissionDetailsPayload = [Components.Schemas.Permission.TeamDrivePermissionDetailsPayloadPayload]
            /// Output only. Deprecated: Output only. Use `permissionDetails` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/teamDrivePermissionDetails`.
            @available(*, deprecated)
            public var teamDrivePermissionDetails: Components.Schemas.Permission.TeamDrivePermissionDetailsPayload?
            /// The type of the grantee. Valid values are: * `user` * `group` * `domain` * `anyone` When creating a permission, if `type` is `user` or `group`, you must provide an `emailAddress` for the user or group. When `type` is `domain`, you must provide a `domain`. There isn't extra information required for an `anyone` type.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/type`.
            public var _type: Swift.String?
            /// Indicates the view for this permission. Only populated for permissions that belong to a view. 'published' is the only supported value.
            ///
            /// - Remark: Generated from `#/components/schemas/Permission/view`.
            public var view: Swift.String?
            /// Creates a new `Permission`.
            ///
            /// - Parameters:
            ///   - allowFileDiscovery: Whether the permission allows the file to be discovered through search. This is only applicable for permissions of type `domain` or `anyone`.
            ///   - deleted: Output only. Whether the account associated with this permission has been deleted. This field only pertains to user and group permissions.
            ///   - displayName: Output only. The "pretty" name of the value of the permission. The following is a list of examples for each type of permission: * `user` - User's full name, as defined for their Google account, such as "Joe Smith." * `group` - Name of the Google Group, such as "The Company Administrators." * `domain` - String domain name, such as "thecompany.com." * `anyone` - No `displayName` is present.
            ///   - domain: The domain to which this permission refers.
            ///   - emailAddress: The email address of the user or group to which this permission refers.
            ///   - expirationTime: The time at which this permission will expire (RFC 3339 date-time). Expiration times have the following restrictions: - They can only be set on user and group permissions - The time must be in the future - The time cannot be more than a year in the future
            ///   - id: Output only. The ID of this permission. This is a unique identifier for the grantee, and is published in User resources as `permissionId`. IDs should be treated as opaque values.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#permission"`.
            ///   - pendingOwner: Whether the account associated with this permission is a pending owner. Only populated for `user` type permissions for files that are not in a shared drive.
            ///   - permissionDetails: Output only. Details of whether the permissions on this shared drive item are inherited or directly on this item. This is an output-only field which is present only for shared drive items.
            ///   - photoLink: Output only. A link to the user's profile photo, if available.
            ///   - role: The role granted by this permission. While new values may be supported in the future, the following are currently allowed: * `owner` * `organizer` * `fileOrganizer` * `writer` * `commenter` * `reader`
            ///   - teamDrivePermissionDetails: Output only. Deprecated: Output only. Use `permissionDetails` instead.
            ///   - _type: The type of the grantee. Valid values are: * `user` * `group` * `domain` * `anyone` When creating a permission, if `type` is `user` or `group`, you must provide an `emailAddress` for the user or group. When `type` is `domain`, you must provide a `domain`. There isn't extra information required for an `anyone` type.
            ///   - view: Indicates the view for this permission. Only populated for permissions that belong to a view. 'published' is the only supported value.
            public init(
                allowFileDiscovery: Swift.Bool? = nil,
                deleted: Swift.Bool? = nil,
                displayName: Swift.String? = nil,
                domain: Swift.String? = nil,
                emailAddress: Swift.String? = nil,
                expirationTime: Foundation.Date? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                pendingOwner: Swift.Bool? = nil,
                permissionDetails: Components.Schemas.Permission.PermissionDetailsPayload? = nil,
                photoLink: Swift.String? = nil,
                role: Swift.String? = nil,
                teamDrivePermissionDetails: Components.Schemas.Permission.TeamDrivePermissionDetailsPayload? = nil,
                _type: Swift.String? = nil,
                view: Swift.String? = nil
            ) {
                self.allowFileDiscovery = allowFileDiscovery
                self.deleted = deleted
                self.displayName = displayName
                self.domain = domain
                self.emailAddress = emailAddress
                self.expirationTime = expirationTime
                self.id = id
                self.kind = kind
                self.pendingOwner = pendingOwner
                self.permissionDetails = permissionDetails
                self.photoLink = photoLink
                self.role = role
                self.teamDrivePermissionDetails = teamDrivePermissionDetails
                self._type = _type
                self.view = view
            }
            public enum CodingKeys: String, CodingKey {
                case allowFileDiscovery
                case deleted
                case displayName
                case domain
                case emailAddress
                case expirationTime
                case id
                case kind
                case pendingOwner
                case permissionDetails
                case photoLink
                case role
                case teamDrivePermissionDetails
                case _type = "type"
                case view
            }
        }
        /// A list of permissions for a file.
        ///
        /// - Remark: Generated from `#/components/schemas/PermissionList`.
        public struct PermissionList: Codable, Hashable, Sendable {
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#permissionList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/PermissionList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of permissions. This field will be absent if the end of the permissions list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/PermissionList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// The list of permissions. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/PermissionList/permissions`.
            public var permissions: [Components.Schemas.Permission]?
            /// Creates a new `PermissionList`.
            ///
            /// - Parameters:
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#permissionList"`.
            ///   - nextPageToken: The page token for the next page of permissions. This field will be absent if the end of the permissions list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///   - permissions: The list of permissions. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            public init(
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil,
                permissions: [Components.Schemas.Permission]? = nil
            ) {
                self.kind = kind
                self.nextPageToken = nextPageToken
                self.permissions = permissions
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case nextPageToken
                case permissions
            }
        }
        /// A reply to a comment on a file. Some resource methods (such as `replies.update`) require a `replyId`. Use the `replies.list` method to retrieve the ID for a reply.
        ///
        /// - Remark: Generated from `#/components/schemas/Reply`.
        public struct Reply: Codable, Hashable, Sendable {
            /// The action the reply performed to the parent comment. Valid values are: * `resolve` * `reopen`
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/action`.
            public var action: Swift.String?
            /// - Remark: Generated from `#/components/schemas/Reply/author`.
            public var author: Components.Schemas.User?
            /// The plain text content of the reply. This field is used for setting the content, while `htmlContent` should be displayed. This is required on creates if no `action` is specified.
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/content`.
            public var content: Swift.String?
            /// The time at which the reply was created (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/createdTime`.
            public var createdTime: Foundation.Date?
            /// Output only. Whether the reply has been deleted. A deleted reply has no content.
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/deleted`.
            public var deleted: Swift.Bool?
            /// Output only. The content of the reply with HTML formatting.
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/htmlContent`.
            public var htmlContent: Swift.String?
            /// Output only. The ID of the reply.
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/id`.
            public var id: Swift.String?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#reply"`.
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/kind`.
            public var kind: Swift.String?
            /// The last time the reply was modified (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Reply/modifiedTime`.
            public var modifiedTime: Foundation.Date?
            /// Creates a new `Reply`.
            ///
            /// - Parameters:
            ///   - action: The action the reply performed to the parent comment. Valid values are: * `resolve` * `reopen`
            ///   - author:
            ///   - content: The plain text content of the reply. This field is used for setting the content, while `htmlContent` should be displayed. This is required on creates if no `action` is specified.
            ///   - createdTime: The time at which the reply was created (RFC 3339 date-time).
            ///   - deleted: Output only. Whether the reply has been deleted. A deleted reply has no content.
            ///   - htmlContent: Output only. The content of the reply with HTML formatting.
            ///   - id: Output only. The ID of the reply.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#reply"`.
            ///   - modifiedTime: The last time the reply was modified (RFC 3339 date-time).
            public init(
                action: Swift.String? = nil,
                author: Components.Schemas.User? = nil,
                content: Swift.String? = nil,
                createdTime: Foundation.Date? = nil,
                deleted: Swift.Bool? = nil,
                htmlContent: Swift.String? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                modifiedTime: Foundation.Date? = nil
            ) {
                self.action = action
                self.author = author
                self.content = content
                self.createdTime = createdTime
                self.deleted = deleted
                self.htmlContent = htmlContent
                self.id = id
                self.kind = kind
                self.modifiedTime = modifiedTime
            }
            public enum CodingKeys: String, CodingKey {
                case action
                case author
                case content
                case createdTime
                case deleted
                case htmlContent
                case id
                case kind
                case modifiedTime
            }
        }
        /// A list of replies to a comment on a file.
        ///
        /// - Remark: Generated from `#/components/schemas/ReplyList`.
        public struct ReplyList: Codable, Hashable, Sendable {
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#replyList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/ReplyList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of replies. This will be absent if the end of the replies list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/ReplyList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// The list of replies. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/ReplyList/replies`.
            public var replies: [Components.Schemas.Reply]?
            /// Creates a new `ReplyList`.
            ///
            /// - Parameters:
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#replyList"`.
            ///   - nextPageToken: The page token for the next page of replies. This will be absent if the end of the replies list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///   - replies: The list of replies. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            public init(
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil,
                replies: [Components.Schemas.Reply]? = nil
            ) {
                self.kind = kind
                self.nextPageToken = nextPageToken
                self.replies = replies
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case nextPageToken
                case replies
            }
        }
        /// The metadata for a revision to a file. Some resource methods (such as `revisions.update`) require a `revisionId`. Use the `revisions.list` method to retrieve the ID for a revision.
        ///
        /// - Remark: Generated from `#/components/schemas/Revision`.
        public struct Revision: Codable, Hashable, Sendable {
            /// Output only. Links for exporting Docs Editors files to specific formats.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/exportLinks`.
            public struct ExportLinksPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `ExportLinksPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// Output only. Links for exporting Docs Editors files to specific formats.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/exportLinks`.
            public var exportLinks: Components.Schemas.Revision.ExportLinksPayload?
            /// Output only. The ID of the revision.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/id`.
            public var id: Swift.String?
            /// Whether to keep this revision forever, even if it is no longer the head revision. If not set, the revision will be automatically purged 30 days after newer content is uploaded. This can be set on a maximum of 200 revisions for a file. This field is only applicable to files with binary content in Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/keepForever`.
            public var keepForever: Swift.Bool?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#revision"`.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/kind`.
            public var kind: Swift.String?
            /// - Remark: Generated from `#/components/schemas/Revision/lastModifyingUser`.
            public var lastModifyingUser: Components.Schemas.User?
            /// Output only. The MD5 checksum of the revision's content. This is only applicable to files with binary content in Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/md5Checksum`.
            public var md5Checksum: Swift.String?
            /// Output only. The MIME type of the revision.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/mimeType`.
            public var mimeType: Swift.String?
            /// The last time the revision was modified (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/modifiedTime`.
            public var modifiedTime: Foundation.Date?
            /// Output only. The original filename used to create this revision. This is only applicable to files with binary content in Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/originalFilename`.
            public var originalFilename: Swift.String?
            /// Whether subsequent revisions will be automatically republished. This is only applicable to Docs Editors files.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/publishAuto`.
            public var publishAuto: Swift.Bool?
            /// Whether this revision is published. This is only applicable to Docs Editors files.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/published`.
            public var published: Swift.Bool?
            /// Output only. A link to the published revision. This is only populated for Google Sites files.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/publishedLink`.
            public var publishedLink: Swift.String?
            /// Whether this revision is published outside the domain. This is only applicable to Docs Editors files.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/publishedOutsideDomain`.
            public var publishedOutsideDomain: Swift.Bool?
            /// Output only. The size of the revision's content in bytes. This is only applicable to files with binary content in Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/Revision/size`.
            public var size: Swift.String?
            /// Creates a new `Revision`.
            ///
            /// - Parameters:
            ///   - exportLinks: Output only. Links for exporting Docs Editors files to specific formats.
            ///   - id: Output only. The ID of the revision.
            ///   - keepForever: Whether to keep this revision forever, even if it is no longer the head revision. If not set, the revision will be automatically purged 30 days after newer content is uploaded. This can be set on a maximum of 200 revisions for a file. This field is only applicable to files with binary content in Drive.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#revision"`.
            ///   - lastModifyingUser:
            ///   - md5Checksum: Output only. The MD5 checksum of the revision's content. This is only applicable to files with binary content in Drive.
            ///   - mimeType: Output only. The MIME type of the revision.
            ///   - modifiedTime: The last time the revision was modified (RFC 3339 date-time).
            ///   - originalFilename: Output only. The original filename used to create this revision. This is only applicable to files with binary content in Drive.
            ///   - publishAuto: Whether subsequent revisions will be automatically republished. This is only applicable to Docs Editors files.
            ///   - published: Whether this revision is published. This is only applicable to Docs Editors files.
            ///   - publishedLink: Output only. A link to the published revision. This is only populated for Google Sites files.
            ///   - publishedOutsideDomain: Whether this revision is published outside the domain. This is only applicable to Docs Editors files.
            ///   - size: Output only. The size of the revision's content in bytes. This is only applicable to files with binary content in Drive.
            public init(
                exportLinks: Components.Schemas.Revision.ExportLinksPayload? = nil,
                id: Swift.String? = nil,
                keepForever: Swift.Bool? = nil,
                kind: Swift.String? = nil,
                lastModifyingUser: Components.Schemas.User? = nil,
                md5Checksum: Swift.String? = nil,
                mimeType: Swift.String? = nil,
                modifiedTime: Foundation.Date? = nil,
                originalFilename: Swift.String? = nil,
                publishAuto: Swift.Bool? = nil,
                published: Swift.Bool? = nil,
                publishedLink: Swift.String? = nil,
                publishedOutsideDomain: Swift.Bool? = nil,
                size: Swift.String? = nil
            ) {
                self.exportLinks = exportLinks
                self.id = id
                self.keepForever = keepForever
                self.kind = kind
                self.lastModifyingUser = lastModifyingUser
                self.md5Checksum = md5Checksum
                self.mimeType = mimeType
                self.modifiedTime = modifiedTime
                self.originalFilename = originalFilename
                self.publishAuto = publishAuto
                self.published = published
                self.publishedLink = publishedLink
                self.publishedOutsideDomain = publishedOutsideDomain
                self.size = size
            }
            public enum CodingKeys: String, CodingKey {
                case exportLinks
                case id
                case keepForever
                case kind
                case lastModifyingUser
                case md5Checksum
                case mimeType
                case modifiedTime
                case originalFilename
                case publishAuto
                case published
                case publishedLink
                case publishedOutsideDomain
                case size
            }
        }
        /// A list of revisions of a file.
        ///
        /// - Remark: Generated from `#/components/schemas/RevisionList`.
        public struct RevisionList: Codable, Hashable, Sendable {
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#revisionList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/RevisionList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of revisions. This will be absent if the end of the revisions list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/RevisionList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// The list of revisions. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/RevisionList/revisions`.
            public var revisions: [Components.Schemas.Revision]?
            /// Creates a new `RevisionList`.
            ///
            /// - Parameters:
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#revisionList"`.
            ///   - nextPageToken: The page token for the next page of revisions. This will be absent if the end of the revisions list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///   - revisions: The list of revisions. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            public init(
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil,
                revisions: [Components.Schemas.Revision]? = nil
            ) {
                self.kind = kind
                self.nextPageToken = nextPageToken
                self.revisions = revisions
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case nextPageToken
                case revisions
            }
        }
        /// - Remark: Generated from `#/components/schemas/StartPageToken`.
        public struct StartPageToken: Codable, Hashable, Sendable {
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#startPageToken"`.
            ///
            /// - Remark: Generated from `#/components/schemas/StartPageToken/kind`.
            public var kind: Swift.String?
            /// The starting page token for listing future changes. The page token doesn't expire.
            ///
            /// - Remark: Generated from `#/components/schemas/StartPageToken/startPageToken`.
            public var startPageToken: Swift.String?
            /// Creates a new `StartPageToken`.
            ///
            /// - Parameters:
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#startPageToken"`.
            ///   - startPageToken: The starting page token for listing future changes. The page token doesn't expire.
            public init(
                kind: Swift.String? = nil,
                startPageToken: Swift.String? = nil
            ) {
                self.kind = kind
                self.startPageToken = startPageToken
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case startPageToken
            }
        }
        /// Deprecated: use the drive collection instead.
        ///
        /// - Remark: Generated from `#/components/schemas/TeamDrive`.
        public struct TeamDrive: Codable, Hashable, Sendable {
            /// An image file and cropping parameters from which a background image for this Team Drive is set. This is a write only field; it can only be set on `drive.teamdrives.update` requests that don't set `themeId`. When specified, all fields of the `backgroundImageFile` must be set.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageFile`.
            public struct BackgroundImageFilePayload: Codable, Hashable, Sendable {
                /// The ID of an image file in Drive to use for the background image.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageFile/id`.
                public var id: Swift.String?
                /// The width of the cropped image in the closed range of 0 to 1. This value represents the width of the cropped image divided by the width of the entire image. The height is computed by applying a width to height aspect ratio of 80 to 9. The resulting image must be at least 1280 pixels wide and 144 pixels high.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageFile/width`.
                public var width: Swift.Float?
                /// The X coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the horizontal distance from the left side of the entire image to the left side of the cropping area divided by the width of the entire image.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageFile/xCoordinate`.
                public var xCoordinate: Swift.Float?
                /// The Y coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the vertical distance from the top side of the entire image to the top side of the cropping area divided by the height of the entire image.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageFile/yCoordinate`.
                public var yCoordinate: Swift.Float?
                /// Creates a new `BackgroundImageFilePayload`.
                ///
                /// - Parameters:
                ///   - id: The ID of an image file in Drive to use for the background image.
                ///   - width: The width of the cropped image in the closed range of 0 to 1. This value represents the width of the cropped image divided by the width of the entire image. The height is computed by applying a width to height aspect ratio of 80 to 9. The resulting image must be at least 1280 pixels wide and 144 pixels high.
                ///   - xCoordinate: The X coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the horizontal distance from the left side of the entire image to the left side of the cropping area divided by the width of the entire image.
                ///   - yCoordinate: The Y coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the vertical distance from the top side of the entire image to the top side of the cropping area divided by the height of the entire image.
                public init(
                    id: Swift.String? = nil,
                    width: Swift.Float? = nil,
                    xCoordinate: Swift.Float? = nil,
                    yCoordinate: Swift.Float? = nil
                ) {
                    self.id = id
                    self.width = width
                    self.xCoordinate = xCoordinate
                    self.yCoordinate = yCoordinate
                }
                public enum CodingKeys: String, CodingKey {
                    case id
                    case width
                    case xCoordinate
                    case yCoordinate
                }
            }
            /// An image file and cropping parameters from which a background image for this Team Drive is set. This is a write only field; it can only be set on `drive.teamdrives.update` requests that don't set `themeId`. When specified, all fields of the `backgroundImageFile` must be set.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageFile`.
            public var backgroundImageFile: Components.Schemas.TeamDrive.BackgroundImageFilePayload?
            /// A short-lived link to this Team Drive's background image.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/backgroundImageLink`.
            public var backgroundImageLink: Swift.String?
            /// Capabilities the current user has on this Team Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities`.
            public struct CapabilitiesPayload: Codable, Hashable, Sendable {
                /// Whether the current user can add children to folders in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canAddChildren`.
                public var canAddChildren: Swift.Bool?
                /// Whether the current user can change the `copyRequiresWriterPermission` restriction of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canChangeCopyRequiresWriterPermissionRestriction`.
                public var canChangeCopyRequiresWriterPermissionRestriction: Swift.Bool?
                /// Whether the current user can change the `domainUsersOnly` restriction of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canChangeDomainUsersOnlyRestriction`.
                public var canChangeDomainUsersOnlyRestriction: Swift.Bool?
                /// Whether the current user can change the `sharingFoldersRequiresOrganizerPermission` restriction of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canChangeSharingFoldersRequiresOrganizerPermissionRestriction`.
                public var canChangeSharingFoldersRequiresOrganizerPermissionRestriction: Swift.Bool?
                /// Whether the current user can change the background of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canChangeTeamDriveBackground`.
                public var canChangeTeamDriveBackground: Swift.Bool?
                /// Whether the current user can change the `teamMembersOnly` restriction of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canChangeTeamMembersOnlyRestriction`.
                public var canChangeTeamMembersOnlyRestriction: Swift.Bool?
                /// Whether the current user can comment on files in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canComment`.
                public var canComment: Swift.Bool?
                /// Whether the current user can copy files in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canCopy`.
                public var canCopy: Swift.Bool?
                /// Whether the current user can delete children from folders in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canDeleteChildren`.
                public var canDeleteChildren: Swift.Bool?
                /// Whether the current user can delete this Team Drive. Attempting to delete the Team Drive may still fail if there are untrashed items inside the Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canDeleteTeamDrive`.
                public var canDeleteTeamDrive: Swift.Bool?
                /// Whether the current user can download files in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canDownload`.
                public var canDownload: Swift.Bool?
                /// Whether the current user can edit files in this Team Drive
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canEdit`.
                public var canEdit: Swift.Bool?
                /// Whether the current user can list the children of folders in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canListChildren`.
                public var canListChildren: Swift.Bool?
                /// Whether the current user can add members to this Team Drive or remove them or change their role.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canManageMembers`.
                public var canManageMembers: Swift.Bool?
                /// Whether the current user can read the revisions resource of files in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canReadRevisions`.
                public var canReadRevisions: Swift.Bool?
                /// Deprecated: Use `canDeleteChildren` or `canTrashChildren` instead.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canRemoveChildren`.
                @available(*, deprecated)
                public var canRemoveChildren: Swift.Bool?
                /// Whether the current user can rename files or folders in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canRename`.
                public var canRename: Swift.Bool?
                /// Whether the current user can rename this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canRenameTeamDrive`.
                public var canRenameTeamDrive: Swift.Bool?
                /// Whether the current user can reset the Team Drive restrictions to defaults.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canResetTeamDriveRestrictions`.
                public var canResetTeamDriveRestrictions: Swift.Bool?
                /// Whether the current user can share files or folders in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canShare`.
                public var canShare: Swift.Bool?
                /// Whether the current user can trash children from folders in this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities/canTrashChildren`.
                public var canTrashChildren: Swift.Bool?
                /// Creates a new `CapabilitiesPayload`.
                ///
                /// - Parameters:
                ///   - canAddChildren: Whether the current user can add children to folders in this Team Drive.
                ///   - canChangeCopyRequiresWriterPermissionRestriction: Whether the current user can change the `copyRequiresWriterPermission` restriction of this Team Drive.
                ///   - canChangeDomainUsersOnlyRestriction: Whether the current user can change the `domainUsersOnly` restriction of this Team Drive.
                ///   - canChangeSharingFoldersRequiresOrganizerPermissionRestriction: Whether the current user can change the `sharingFoldersRequiresOrganizerPermission` restriction of this Team Drive.
                ///   - canChangeTeamDriveBackground: Whether the current user can change the background of this Team Drive.
                ///   - canChangeTeamMembersOnlyRestriction: Whether the current user can change the `teamMembersOnly` restriction of this Team Drive.
                ///   - canComment: Whether the current user can comment on files in this Team Drive.
                ///   - canCopy: Whether the current user can copy files in this Team Drive.
                ///   - canDeleteChildren: Whether the current user can delete children from folders in this Team Drive.
                ///   - canDeleteTeamDrive: Whether the current user can delete this Team Drive. Attempting to delete the Team Drive may still fail if there are untrashed items inside the Team Drive.
                ///   - canDownload: Whether the current user can download files in this Team Drive.
                ///   - canEdit: Whether the current user can edit files in this Team Drive
                ///   - canListChildren: Whether the current user can list the children of folders in this Team Drive.
                ///   - canManageMembers: Whether the current user can add members to this Team Drive or remove them or change their role.
                ///   - canReadRevisions: Whether the current user can read the revisions resource of files in this Team Drive.
                ///   - canRemoveChildren: Deprecated: Use `canDeleteChildren` or `canTrashChildren` instead.
                ///   - canRename: Whether the current user can rename files or folders in this Team Drive.
                ///   - canRenameTeamDrive: Whether the current user can rename this Team Drive.
                ///   - canResetTeamDriveRestrictions: Whether the current user can reset the Team Drive restrictions to defaults.
                ///   - canShare: Whether the current user can share files or folders in this Team Drive.
                ///   - canTrashChildren: Whether the current user can trash children from folders in this Team Drive.
                public init(
                    canAddChildren: Swift.Bool? = nil,
                    canChangeCopyRequiresWriterPermissionRestriction: Swift.Bool? = nil,
                    canChangeDomainUsersOnlyRestriction: Swift.Bool? = nil,
                    canChangeSharingFoldersRequiresOrganizerPermissionRestriction: Swift.Bool? = nil,
                    canChangeTeamDriveBackground: Swift.Bool? = nil,
                    canChangeTeamMembersOnlyRestriction: Swift.Bool? = nil,
                    canComment: Swift.Bool? = nil,
                    canCopy: Swift.Bool? = nil,
                    canDeleteChildren: Swift.Bool? = nil,
                    canDeleteTeamDrive: Swift.Bool? = nil,
                    canDownload: Swift.Bool? = nil,
                    canEdit: Swift.Bool? = nil,
                    canListChildren: Swift.Bool? = nil,
                    canManageMembers: Swift.Bool? = nil,
                    canReadRevisions: Swift.Bool? = nil,
                    canRemoveChildren: Swift.Bool? = nil,
                    canRename: Swift.Bool? = nil,
                    canRenameTeamDrive: Swift.Bool? = nil,
                    canResetTeamDriveRestrictions: Swift.Bool? = nil,
                    canShare: Swift.Bool? = nil,
                    canTrashChildren: Swift.Bool? = nil
                ) {
                    self.canAddChildren = canAddChildren
                    self.canChangeCopyRequiresWriterPermissionRestriction = canChangeCopyRequiresWriterPermissionRestriction
                    self.canChangeDomainUsersOnlyRestriction = canChangeDomainUsersOnlyRestriction
                    self.canChangeSharingFoldersRequiresOrganizerPermissionRestriction = canChangeSharingFoldersRequiresOrganizerPermissionRestriction
                    self.canChangeTeamDriveBackground = canChangeTeamDriveBackground
                    self.canChangeTeamMembersOnlyRestriction = canChangeTeamMembersOnlyRestriction
                    self.canComment = canComment
                    self.canCopy = canCopy
                    self.canDeleteChildren = canDeleteChildren
                    self.canDeleteTeamDrive = canDeleteTeamDrive
                    self.canDownload = canDownload
                    self.canEdit = canEdit
                    self.canListChildren = canListChildren
                    self.canManageMembers = canManageMembers
                    self.canReadRevisions = canReadRevisions
                    self.canRemoveChildren = canRemoveChildren
                    self.canRename = canRename
                    self.canRenameTeamDrive = canRenameTeamDrive
                    self.canResetTeamDriveRestrictions = canResetTeamDriveRestrictions
                    self.canShare = canShare
                    self.canTrashChildren = canTrashChildren
                }
                public enum CodingKeys: String, CodingKey {
                    case canAddChildren
                    case canChangeCopyRequiresWriterPermissionRestriction
                    case canChangeDomainUsersOnlyRestriction
                    case canChangeSharingFoldersRequiresOrganizerPermissionRestriction
                    case canChangeTeamDriveBackground
                    case canChangeTeamMembersOnlyRestriction
                    case canComment
                    case canCopy
                    case canDeleteChildren
                    case canDeleteTeamDrive
                    case canDownload
                    case canEdit
                    case canListChildren
                    case canManageMembers
                    case canReadRevisions
                    case canRemoveChildren
                    case canRename
                    case canRenameTeamDrive
                    case canResetTeamDriveRestrictions
                    case canShare
                    case canTrashChildren
                }
            }
            /// Capabilities the current user has on this Team Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/capabilities`.
            public var capabilities: Components.Schemas.TeamDrive.CapabilitiesPayload?
            /// The color of this Team Drive as an RGB hex string. It can only be set on a `drive.teamdrives.update` request that does not set `themeId`.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/colorRgb`.
            public var colorRgb: Swift.String?
            /// The time at which the Team Drive was created (RFC 3339 date-time).
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/createdTime`.
            public var createdTime: Foundation.Date?
            /// The ID of this Team Drive which is also the ID of the top level folder of this Team Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/id`.
            public var id: Swift.String?
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#teamDrive"`.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/kind`.
            public var kind: Swift.String?
            /// The name of this Team Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/name`.
            public var name: Swift.String?
            /// The organizational unit of this shared drive. This field is only populated on `drives.list` responses when the `useDomainAdminAccess` parameter is set to `true`.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/orgUnitId`.
            public var orgUnitId: Swift.String?
            /// A set of restrictions that apply to this Team Drive or items inside this Team Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions`.
            public struct RestrictionsPayload: Codable, Hashable, Sendable {
                /// Whether administrative privileges on this Team Drive are required to modify restrictions.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions/adminManagedRestrictions`.
                public var adminManagedRestrictions: Swift.Bool?
                /// Whether the options to copy, print, or download files inside this Team Drive, should be disabled for readers and commenters. When this restriction is set to `true`, it will override the similarly named field to `true` for any file inside this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions/copyRequiresWriterPermission`.
                public var copyRequiresWriterPermission: Swift.Bool?
                /// Whether access to this Team Drive and items inside this Team Drive is restricted to users of the domain to which this Team Drive belongs. This restriction may be overridden by other sharing policies controlled outside of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions/domainUsersOnly`.
                public var domainUsersOnly: Swift.Bool?
                /// If true, only users with the organizer role can share folders. If false, users with either the organizer role or the file organizer role can share folders.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions/sharingFoldersRequiresOrganizerPermission`.
                public var sharingFoldersRequiresOrganizerPermission: Swift.Bool?
                /// Whether access to items inside this Team Drive is restricted to members of this Team Drive.
                ///
                /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions/teamMembersOnly`.
                public var teamMembersOnly: Swift.Bool?
                /// Creates a new `RestrictionsPayload`.
                ///
                /// - Parameters:
                ///   - adminManagedRestrictions: Whether administrative privileges on this Team Drive are required to modify restrictions.
                ///   - copyRequiresWriterPermission: Whether the options to copy, print, or download files inside this Team Drive, should be disabled for readers and commenters. When this restriction is set to `true`, it will override the similarly named field to `true` for any file inside this Team Drive.
                ///   - domainUsersOnly: Whether access to this Team Drive and items inside this Team Drive is restricted to users of the domain to which this Team Drive belongs. This restriction may be overridden by other sharing policies controlled outside of this Team Drive.
                ///   - sharingFoldersRequiresOrganizerPermission: If true, only users with the organizer role can share folders. If false, users with either the organizer role or the file organizer role can share folders.
                ///   - teamMembersOnly: Whether access to items inside this Team Drive is restricted to members of this Team Drive.
                public init(
                    adminManagedRestrictions: Swift.Bool? = nil,
                    copyRequiresWriterPermission: Swift.Bool? = nil,
                    domainUsersOnly: Swift.Bool? = nil,
                    sharingFoldersRequiresOrganizerPermission: Swift.Bool? = nil,
                    teamMembersOnly: Swift.Bool? = nil
                ) {
                    self.adminManagedRestrictions = adminManagedRestrictions
                    self.copyRequiresWriterPermission = copyRequiresWriterPermission
                    self.domainUsersOnly = domainUsersOnly
                    self.sharingFoldersRequiresOrganizerPermission = sharingFoldersRequiresOrganizerPermission
                    self.teamMembersOnly = teamMembersOnly
                }
                public enum CodingKeys: String, CodingKey {
                    case adminManagedRestrictions
                    case copyRequiresWriterPermission
                    case domainUsersOnly
                    case sharingFoldersRequiresOrganizerPermission
                    case teamMembersOnly
                }
            }
            /// A set of restrictions that apply to this Team Drive or items inside this Team Drive.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/restrictions`.
            public var restrictions: Components.Schemas.TeamDrive.RestrictionsPayload?
            /// The ID of the theme from which the background image and color will be set. The set of possible `teamDriveThemes` can be retrieved from a `drive.about.get` response. When not specified on a `drive.teamdrives.create` request, a random theme is chosen from which the background image and color are set. This is a write-only field; it can only be set on requests that don't set `colorRgb` or `backgroundImageFile`.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDrive/themeId`.
            public var themeId: Swift.String?
            /// Creates a new `TeamDrive`.
            ///
            /// - Parameters:
            ///   - backgroundImageFile: An image file and cropping parameters from which a background image for this Team Drive is set. This is a write only field; it can only be set on `drive.teamdrives.update` requests that don't set `themeId`. When specified, all fields of the `backgroundImageFile` must be set.
            ///   - backgroundImageLink: A short-lived link to this Team Drive's background image.
            ///   - capabilities: Capabilities the current user has on this Team Drive.
            ///   - colorRgb: The color of this Team Drive as an RGB hex string. It can only be set on a `drive.teamdrives.update` request that does not set `themeId`.
            ///   - createdTime: The time at which the Team Drive was created (RFC 3339 date-time).
            ///   - id: The ID of this Team Drive which is also the ID of the top level folder of this Team Drive.
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#teamDrive"`.
            ///   - name: The name of this Team Drive.
            ///   - orgUnitId: The organizational unit of this shared drive. This field is only populated on `drives.list` responses when the `useDomainAdminAccess` parameter is set to `true`.
            ///   - restrictions: A set of restrictions that apply to this Team Drive or items inside this Team Drive.
            ///   - themeId: The ID of the theme from which the background image and color will be set. The set of possible `teamDriveThemes` can be retrieved from a `drive.about.get` response. When not specified on a `drive.teamdrives.create` request, a random theme is chosen from which the background image and color are set. This is a write-only field; it can only be set on requests that don't set `colorRgb` or `backgroundImageFile`.
            public init(
                backgroundImageFile: Components.Schemas.TeamDrive.BackgroundImageFilePayload? = nil,
                backgroundImageLink: Swift.String? = nil,
                capabilities: Components.Schemas.TeamDrive.CapabilitiesPayload? = nil,
                colorRgb: Swift.String? = nil,
                createdTime: Foundation.Date? = nil,
                id: Swift.String? = nil,
                kind: Swift.String? = nil,
                name: Swift.String? = nil,
                orgUnitId: Swift.String? = nil,
                restrictions: Components.Schemas.TeamDrive.RestrictionsPayload? = nil,
                themeId: Swift.String? = nil
            ) {
                self.backgroundImageFile = backgroundImageFile
                self.backgroundImageLink = backgroundImageLink
                self.capabilities = capabilities
                self.colorRgb = colorRgb
                self.createdTime = createdTime
                self.id = id
                self.kind = kind
                self.name = name
                self.orgUnitId = orgUnitId
                self.restrictions = restrictions
                self.themeId = themeId
            }
            public enum CodingKeys: String, CodingKey {
                case backgroundImageFile
                case backgroundImageLink
                case capabilities
                case colorRgb
                case createdTime
                case id
                case kind
                case name
                case orgUnitId
                case restrictions
                case themeId
            }
        }
        /// A list of Team Drives.
        ///
        /// - Remark: Generated from `#/components/schemas/TeamDriveList`.
        public struct TeamDriveList: Codable, Hashable, Sendable {
            /// Identifies what kind of resource this is. Value: the fixed string `"drive#teamDriveList"`.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDriveList/kind`.
            public var kind: Swift.String?
            /// The page token for the next page of Team Drives. This will be absent if the end of the Team Drives list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDriveList/nextPageToken`.
            public var nextPageToken: Swift.String?
            /// The list of Team Drives. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            ///
            /// - Remark: Generated from `#/components/schemas/TeamDriveList/teamDrives`.
            public var teamDrives: [Components.Schemas.TeamDrive]?
            /// Creates a new `TeamDriveList`.
            ///
            /// - Parameters:
            ///   - kind: Identifies what kind of resource this is. Value: the fixed string `"drive#teamDriveList"`.
            ///   - nextPageToken: The page token for the next page of Team Drives. This will be absent if the end of the Team Drives list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results. The page token is typically valid for several hours. However, if new items are added or removed, your expected results might differ.
            ///   - teamDrives: The list of Team Drives. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched.
            public init(
                kind: Swift.String? = nil,
                nextPageToken: Swift.String? = nil,
                teamDrives: [Components.Schemas.TeamDrive]? = nil
            ) {
                self.kind = kind
                self.nextPageToken = nextPageToken
                self.teamDrives = teamDrives
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case nextPageToken
                case teamDrives
            }
        }
        /// Information about a Drive user.
        ///
        /// - Remark: Generated from `#/components/schemas/User`.
        public struct User: Codable, Hashable, Sendable {
            /// Output only. A plain text displayable name for this user.
            ///
            /// - Remark: Generated from `#/components/schemas/User/displayName`.
            public var displayName: Swift.String?
            /// Output only. The email address of the user. This may not be present in certain contexts if the user has not made their email address visible to the requester.
            ///
            /// - Remark: Generated from `#/components/schemas/User/emailAddress`.
            public var emailAddress: Swift.String?
            /// Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#user"`.
            ///
            /// - Remark: Generated from `#/components/schemas/User/kind`.
            public var kind: Swift.String?
            /// Output only. Whether this user is the requesting user.
            ///
            /// - Remark: Generated from `#/components/schemas/User/me`.
            public var me: Swift.Bool?
            /// Output only. The user's ID as visible in Permission resources.
            ///
            /// - Remark: Generated from `#/components/schemas/User/permissionId`.
            public var permissionId: Swift.String?
            /// Output only. A link to the user's profile photo, if available.
            ///
            /// - Remark: Generated from `#/components/schemas/User/photoLink`.
            public var photoLink: Swift.String?
            /// Creates a new `User`.
            ///
            /// - Parameters:
            ///   - displayName: Output only. A plain text displayable name for this user.
            ///   - emailAddress: Output only. The email address of the user. This may not be present in certain contexts if the user has not made their email address visible to the requester.
            ///   - kind: Output only. Identifies what kind of resource this is. Value: the fixed string `"drive#user"`.
            ///   - me: Output only. Whether this user is the requesting user.
            ///   - permissionId: Output only. The user's ID as visible in Permission resources.
            ///   - photoLink: Output only. A link to the user's profile photo, if available.
            public init(
                displayName: Swift.String? = nil,
                emailAddress: Swift.String? = nil,
                kind: Swift.String? = nil,
                me: Swift.Bool? = nil,
                permissionId: Swift.String? = nil,
                photoLink: Swift.String? = nil
            ) {
                self.displayName = displayName
                self.emailAddress = emailAddress
                self.kind = kind
                self.me = me
                self.permissionId = permissionId
                self.photoLink = photoLink
            }
            public enum CodingKeys: String, CodingKey {
                case displayName
                case emailAddress
                case kind
                case me
                case permissionId
                case photoLink
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {
        /// V1 error format.
        ///
        /// - Remark: Generated from `#/components/parameters/_.xgafv`.
        @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
        }
        /// OAuth access token.
        ///
        /// - Remark: Generated from `#/components/parameters/access_token`.
        public typealias AccessToken = Swift.String
        /// Data format for response.
        ///
        /// - Remark: Generated from `#/components/parameters/alt`.
        @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
            case json = "json"
            case media = "media"
            case proto = "proto"
        }
        /// JSONP
        ///
        /// - Remark: Generated from `#/components/parameters/callback`.
        public typealias Callback = Swift.String
        /// Selector specifying which fields to include in a partial response.
        ///
        /// - Remark: Generated from `#/components/parameters/fields`.
        public typealias Fields = Swift.String
        /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        ///
        /// - Remark: Generated from `#/components/parameters/key`.
        public typealias Key = Swift.String
        /// OAuth 2.0 token for the current user.
        ///
        /// - Remark: Generated from `#/components/parameters/oauth_token`.
        public typealias OauthToken = Swift.String
        /// Returns response with indentations and line breaks.
        ///
        /// - Remark: Generated from `#/components/parameters/prettyPrint`.
        public typealias PrettyPrint = Swift.Bool
        /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        ///
        /// - Remark: Generated from `#/components/parameters/quotaUser`.
        public typealias QuotaUser = Swift.String
        /// Legacy upload protocol for media (e.g. "media", "multipart").
        ///
        /// - Remark: Generated from `#/components/parameters/uploadType`.
        public typealias UploadType = Swift.String
        /// Upload protocol for media (e.g. "raw", "multipart").
        ///
        /// - Remark: Generated from `#/components/parameters/upload_protocol`.
        public typealias UploadProtocol = Swift.String
    }
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Gets information about the user, the user's Drive, and system capabilities.
    ///
    /// - Remark: HTTP `GET /about`.
    /// - Remark: Generated from `#/paths//about/get(drive.about.get)`.
    public enum Drive_about_get {
        public static let id: Swift.String = "drive.about.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/about/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/about/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_about_get.Input.Query
            /// - Remark: Generated from `#/paths/about/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_about_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_about_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_about_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_about_get.Input.Query = .init(),
                headers: Operations.Drive_about_get.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/about/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/about/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.About)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.About {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_about_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_about_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//about/get(drive.about.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_about_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_about_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Lists a user's installed apps.
    ///
    /// - Remark: HTTP `GET /apps`.
    /// - Remark: Generated from `#/paths//apps/get(drive.apps.list)`.
    public enum Drive_apps_list {
        public static let id: Swift.String = "drive.apps.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/apps/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// A comma-separated list of file extensions to limit returned results. All results within the given app query scope which can open any of the given file extensions are included in the response. If `appFilterMimeTypes` are provided as well, the result is a union of the two resulting app lists.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/appFilterExtensions`.
                public var appFilterExtensions: Swift.String?
                /// A comma-separated list of file extensions to limit returned results. All results within the given app query scope which can open any of the given MIME types will be included in the response. If `appFilterExtensions` are provided as well, the result is a union of the two resulting app lists.
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/appFilterMimeTypes`.
                public var appFilterMimeTypes: Swift.String?
                /// A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/).
                ///
                /// - Remark: Generated from `#/paths/apps/GET/query/languageCode`.
                public var languageCode: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - appFilterExtensions: A comma-separated list of file extensions to limit returned results. All results within the given app query scope which can open any of the given file extensions are included in the response. If `appFilterMimeTypes` are provided as well, the result is a union of the two resulting app lists.
                ///   - appFilterMimeTypes: A comma-separated list of file extensions to limit returned results. All results within the given app query scope which can open any of the given MIME types will be included in the response. If `appFilterExtensions` are provided as well, the result is a union of the two resulting app lists.
                ///   - languageCode: A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/).
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    appFilterExtensions: Swift.String? = nil,
                    appFilterMimeTypes: Swift.String? = nil,
                    languageCode: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.appFilterExtensions = appFilterExtensions
                    self.appFilterMimeTypes = appFilterMimeTypes
                    self.languageCode = languageCode
                }
            }
            public var query: Operations.Drive_apps_list.Input.Query
            /// - Remark: Generated from `#/paths/apps/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_apps_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_apps_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_apps_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_apps_list.Input.Query = .init(),
                headers: Operations.Drive_apps_list.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/apps/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/apps/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.AppList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.AppList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_apps_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_apps_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//apps/get(drive.apps.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_apps_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_apps_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets a specific app.
    ///
    /// - Remark: HTTP `GET /apps/{appId}`.
    /// - Remark: Generated from `#/paths//apps/{appId}/get(drive.apps.get)`.
    public enum Drive_apps_get {
        public static let id: Swift.String = "drive.apps.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/apps/{appId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the app.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/path/appId`.
                public var appId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - appId: The ID of the app.
                public init(appId: Swift.String) {
                    self.appId = appId
                }
            }
            public var path: Operations.Drive_apps_get.Input.Path
            /// - Remark: Generated from `#/paths/apps/{appId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_apps_get.Input.Query
            /// - Remark: Generated from `#/paths/apps/{appId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_apps_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_apps_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_apps_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_apps_get.Input.Path,
                query: Operations.Drive_apps_get.Input.Query = .init(),
                headers: Operations.Drive_apps_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/apps/{appId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/apps/{appId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.App)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.App {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_apps_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_apps_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//apps/{appId}/get(drive.apps.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_apps_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_apps_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Lists the changes for a user or shared drive.
    ///
    /// - Remark: HTTP `GET /changes`.
    /// - Remark: Generated from `#/paths//changes/get(drive.changes.list)`.
    public enum Drive_changes_list {
        public static let id: Swift.String = "drive.changes.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/changes/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/pageToken`.
                public var pageToken: Swift.String
                /// The shared drive from which changes will be returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/driveId`.
                public var driveId: Swift.String?
                /// Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/includeCorpusRemovals`.
                public var includeCorpusRemovals: Swift.Bool?
                /// Whether both My Drive and shared drive items should be included in results.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/includeItemsFromAllDrives`.
                public var includeItemsFromAllDrives: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/includeRemoved`.
                public var includeRemoved: Swift.Bool?
                /// Deprecated: Use `includeItemsFromAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/includeTeamDriveItems`.
                public var includeTeamDriveItems: Swift.Bool?
                /// The maximum number of changes to return per page.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// Whether to restrict the results to changes inside the My Drive hierarchy. This omits changes to files such as those in the Application Data folder or shared files which have not been added to My Drive.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/restrictToMyDrive`.
                public var restrictToMyDrive: Swift.Bool?
                /// A comma-separated list of spaces to query within the corpora. Supported values are 'drive' and 'appDataFolder'.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/spaces`.
                public var spaces: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Deprecated: Use `driveId` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/GET/query/teamDriveId`.
                public var teamDriveId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method.
                ///   - driveId: The shared drive from which changes will be returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier.
                ///   - includeCorpusRemovals: Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file.
                ///   - includeItemsFromAllDrives: Whether both My Drive and shared drive items should be included in results.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - includeRemoved: Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access.
                ///   - includeTeamDriveItems: Deprecated: Use `includeItemsFromAllDrives` instead.
                ///   - pageSize: The maximum number of changes to return per page.
                ///   - restrictToMyDrive: Whether to restrict the results to changes inside the My Drive hierarchy. This omits changes to files such as those in the Application Data folder or shared files which have not been added to My Drive.
                ///   - spaces: A comma-separated list of spaces to query within the corpora. Supported values are 'drive' and 'appDataFolder'.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - teamDriveId: Deprecated: Use `driveId` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    pageToken: Swift.String,
                    driveId: Swift.String? = nil,
                    includeCorpusRemovals: Swift.Bool? = nil,
                    includeItemsFromAllDrives: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    includeRemoved: Swift.Bool? = nil,
                    includeTeamDriveItems: Swift.Bool? = nil,
                    pageSize: Swift.Int? = nil,
                    restrictToMyDrive: Swift.Bool? = nil,
                    spaces: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    teamDriveId: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.pageToken = pageToken
                    self.driveId = driveId
                    self.includeCorpusRemovals = includeCorpusRemovals
                    self.includeItemsFromAllDrives = includeItemsFromAllDrives
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.includeRemoved = includeRemoved
                    self.includeTeamDriveItems = includeTeamDriveItems
                    self.pageSize = pageSize
                    self.restrictToMyDrive = restrictToMyDrive
                    self.spaces = spaces
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.teamDriveId = teamDriveId
                }
            }
            public var query: Operations.Drive_changes_list.Input.Query
            /// - Remark: Generated from `#/paths/changes/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_changes_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_changes_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_changes_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_changes_list.Input.Query,
                headers: Operations.Drive_changes_list.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/changes/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/changes/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChangeList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChangeList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_changes_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_changes_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//changes/get(drive.changes.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_changes_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_changes_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets the starting pageToken for listing future changes.
    ///
    /// - Remark: HTTP `GET /changes/startPageToken`.
    /// - Remark: Generated from `#/paths//changes/startPageToken/get(drive.changes.getStartPageToken)`.
    public enum Drive_changes_getStartPageToken {
        public static let id: Swift.String = "drive.changes.getStartPageToken"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// The ID of the shared drive for which the starting pageToken for listing future changes from that shared drive will be returned.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/driveId`.
                public var driveId: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Deprecated: Use `driveId` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/query/teamDriveId`.
                public var teamDriveId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - driveId: The ID of the shared drive for which the starting pageToken for listing future changes from that shared drive will be returned.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - teamDriveId: Deprecated: Use `driveId` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    driveId: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    teamDriveId: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.driveId = driveId
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.teamDriveId = teamDriveId
                }
            }
            public var query: Operations.Drive_changes_getStartPageToken.Input.Query
            /// - Remark: Generated from `#/paths/changes/startPageToken/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_changes_getStartPageToken.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_changes_getStartPageToken.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_changes_getStartPageToken.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_changes_getStartPageToken.Input.Query = .init(),
                headers: Operations.Drive_changes_getStartPageToken.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/changes/startPageToken/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/changes/startPageToken/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.StartPageToken)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StartPageToken {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_changes_getStartPageToken.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_changes_getStartPageToken.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//changes/startPageToken/get(drive.changes.getStartPageToken)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_changes_getStartPageToken.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_changes_getStartPageToken.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Subscribes to changes for a user.
    ///
    /// - Remark: HTTP `POST /changes/watch`.
    /// - Remark: Generated from `#/paths//changes/watch/post(drive.changes.watch)`.
    public enum Drive_changes_watch {
        public static let id: Swift.String = "drive.changes.watch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/changes/watch/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/pageToken`.
                public var pageToken: Swift.String
                /// The shared drive from which changes will be returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/driveId`.
                public var driveId: Swift.String?
                /// Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/includeCorpusRemovals`.
                public var includeCorpusRemovals: Swift.Bool?
                /// Whether both My Drive and shared drive items should be included in results.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/includeItemsFromAllDrives`.
                public var includeItemsFromAllDrives: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/includeRemoved`.
                public var includeRemoved: Swift.Bool?
                /// Deprecated: Use `includeItemsFromAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/includeTeamDriveItems`.
                public var includeTeamDriveItems: Swift.Bool?
                /// The maximum number of changes to return per page.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/pageSize`.
                public var pageSize: Swift.Int?
                /// Whether to restrict the results to changes inside the My Drive hierarchy. This omits changes to files such as those in the Application Data folder or shared files which have not been added to My Drive.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/restrictToMyDrive`.
                public var restrictToMyDrive: Swift.Bool?
                /// A comma-separated list of spaces to query within the corpora. Supported values are 'drive' and 'appDataFolder'.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/spaces`.
                public var spaces: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Deprecated: Use `driveId` instead.
                ///
                /// - Remark: Generated from `#/paths/changes/watch/POST/query/teamDriveId`.
                public var teamDriveId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method.
                ///   - driveId: The shared drive from which changes will be returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier.
                ///   - includeCorpusRemovals: Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file.
                ///   - includeItemsFromAllDrives: Whether both My Drive and shared drive items should be included in results.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - includeRemoved: Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access.
                ///   - includeTeamDriveItems: Deprecated: Use `includeItemsFromAllDrives` instead.
                ///   - pageSize: The maximum number of changes to return per page.
                ///   - restrictToMyDrive: Whether to restrict the results to changes inside the My Drive hierarchy. This omits changes to files such as those in the Application Data folder or shared files which have not been added to My Drive.
                ///   - spaces: A comma-separated list of spaces to query within the corpora. Supported values are 'drive' and 'appDataFolder'.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - teamDriveId: Deprecated: Use `driveId` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    pageToken: Swift.String,
                    driveId: Swift.String? = nil,
                    includeCorpusRemovals: Swift.Bool? = nil,
                    includeItemsFromAllDrives: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    includeRemoved: Swift.Bool? = nil,
                    includeTeamDriveItems: Swift.Bool? = nil,
                    pageSize: Swift.Int? = nil,
                    restrictToMyDrive: Swift.Bool? = nil,
                    spaces: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    teamDriveId: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.pageToken = pageToken
                    self.driveId = driveId
                    self.includeCorpusRemovals = includeCorpusRemovals
                    self.includeItemsFromAllDrives = includeItemsFromAllDrives
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.includeRemoved = includeRemoved
                    self.includeTeamDriveItems = includeTeamDriveItems
                    self.pageSize = pageSize
                    self.restrictToMyDrive = restrictToMyDrive
                    self.spaces = spaces
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.teamDriveId = teamDriveId
                }
            }
            public var query: Operations.Drive_changes_watch.Input.Query
            /// - Remark: Generated from `#/paths/changes/watch/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_changes_watch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_changes_watch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_changes_watch.Input.Headers
            /// - Remark: Generated from `#/paths/changes/watch/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/changes/watch/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Channel)
            }
            public var body: Operations.Drive_changes_watch.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                query: Operations.Drive_changes_watch.Input.Query,
                headers: Operations.Drive_changes_watch.Input.Headers = .init(),
                body: Operations.Drive_changes_watch.Input.Body? = nil
            ) {
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/changes/watch/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/changes/watch/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Channel)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Channel {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_changes_watch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_changes_watch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//changes/watch/post(drive.changes.watch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_changes_watch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_changes_watch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Stops watching resources through this channel.
    ///
    /// - Remark: HTTP `POST /channels/stop`.
    /// - Remark: Generated from `#/paths//channels/stop/post(drive.channels.stop)`.
    public enum Drive_channels_stop {
        public static let id: Swift.String = "drive.channels.stop"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/channels/stop/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/channels/stop/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_channels_stop.Input.Query
            /// - Remark: Generated from `#/paths/channels/stop/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/channels/stop/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Channel)
            }
            public var body: Operations.Drive_channels_stop.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - body:
            public init(
                query: Operations.Drive_channels_stop.Input.Query = .init(),
                body: Operations.Drive_channels_stop.Input.Body? = nil
            ) {
                self.query = query
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//channels/stop/post(drive.channels.stop)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_channels_stop.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//channels/stop/post(drive.channels.stop)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_channels_stop.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    ///  Lists the user's shared drives. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for shared drives](/drive/api/guides/search-shareddrives) guide.
    ///
    /// - Remark: HTTP `GET /drives`.
    /// - Remark: Generated from `#/paths//drives/get(drive.drives.list)`.
    public enum Drive_drives_list {
        public static let id: Swift.String = "drive.drives.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Maximum number of shared drives to return per page.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// Page token for shared drives.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// Query string for searching shared drives.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/q`.
                public var q: Swift.String?
                /// Issue the request as a domain administrator; if set to true, then all shared drives of the domain in which the requester is an administrator are returned.
                ///
                /// - Remark: Generated from `#/paths/drives/GET/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - pageSize: Maximum number of shared drives to return per page.
                ///   - pageToken: Page token for shared drives.
                ///   - q: Query string for searching shared drives.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then all shared drives of the domain in which the requester is an administrator are returned.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil,
                    q: Swift.String? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                    self.q = q
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_drives_list.Input.Query
            /// - Remark: Generated from `#/paths/drives/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_drives_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_drives_list.Input.Query = .init(),
                headers: Operations.Drive_drives_list.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/drives/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.DriveList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DriveList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_drives_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_drives_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/get(drive.drives.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Creates a shared drive.
    ///
    /// - Remark: HTTP `POST /drives`.
    /// - Remark: Generated from `#/paths//drives/post(drive.drives.create)`.
    public enum Drive_drives_create {
        public static let id: Swift.String = "drive.drives.create"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Required. An ID, such as a random UUID, which uniquely identifies this user's request for idempotent creation of a shared drive. A repeated request by the same user and with the same request ID will avoid creating duplicates by attempting to create the same shared drive. If the shared drive already exists a 409 error will be returned.
                ///
                /// - Remark: Generated from `#/paths/drives/POST/query/requestId`.
                public var requestId: Swift.String
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - requestId: Required. An ID, such as a random UUID, which uniquely identifies this user's request for idempotent creation of a shared drive. A repeated request by the same user and with the same request ID will avoid creating duplicates by attempting to create the same shared drive. If the shared drive already exists a 409 error will be returned.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    requestId: Swift.String
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.requestId = requestId
                }
            }
            public var query: Operations.Drive_drives_create.Input.Query
            /// - Remark: Generated from `#/paths/drives/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_create.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_create.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_drives_create.Input.Headers
            /// - Remark: Generated from `#/paths/drives/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Drive)
            }
            public var body: Operations.Drive_drives_create.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                query: Operations.Drive_drives_create.Input.Query,
                headers: Operations.Drive_drives_create.Input.Headers = .init(),
                body: Operations.Drive_drives_create.Input.Body? = nil
            ) {
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/drives/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Drive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Drive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_drives_create.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_drives_create.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/post(drive.drives.create)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_create.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_create.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets a shared drive's metadata by ID.
    ///
    /// - Remark: HTTP `GET /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/get(drive.drives.get)`.
    public enum Drive_drives_get {
        public static let id: Swift.String = "drive.drives.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/{driveId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the shared drive.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/path/driveId`.
                public var driveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - driveId: The ID of the shared drive.
                public init(driveId: Swift.String) {
                    self.driveId = driveId
                }
            }
            public var path: Operations.Drive_drives_get.Input.Path
            /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_drives_get.Input.Query
            /// - Remark: Generated from `#/paths/drives/{driveId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_drives_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_drives_get.Input.Path,
                query: Operations.Drive_drives_get.Input.Query = .init(),
                headers: Operations.Drive_drives_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/{driveId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/drives/{driveId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Drive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Drive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_drives_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_drives_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/{driveId}/get(drive.drives.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Updates the metadate for a shared drive.
    ///
    /// - Remark: HTTP `PATCH /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/patch(drive.drives.update)`.
    public enum Drive_drives_update {
        public static let id: Swift.String = "drive.drives.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the shared drive.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/path/driveId`.
                public var driveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - driveId: The ID of the shared drive.
                public init(driveId: Swift.String) {
                    self.driveId = driveId
                }
            }
            public var path: Operations.Drive_drives_update.Input.Path
            /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_drives_update.Input.Query
            /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_drives_update.Input.Headers
            /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/requestBody/content/application\/json`.
                case json(Components.Schemas.Drive)
            }
            public var body: Operations.Drive_drives_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_drives_update.Input.Path,
                query: Operations.Drive_drives_update.Input.Query = .init(),
                headers: Operations.Drive_drives_update.Input.Headers = .init(),
                body: Operations.Drive_drives_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/drives/{driveId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Drive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Drive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_drives_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_drives_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/{driveId}/patch(drive.drives.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Permanently deletes a shared drive for which the user is an `organizer`. The shared drive cannot contain any untrashed items.
    ///
    /// - Remark: HTTP `DELETE /drives/{driveId}`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/delete(drive.drives.delete)`.
    public enum Drive_drives_delete {
        public static let id: Swift.String = "drive.drives.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the shared drive.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/path/driveId`.
                public var driveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - driveId: The ID of the shared drive.
                public init(driveId: Swift.String) {
                    self.driveId = driveId
                }
            }
            public var path: Operations.Drive_drives_delete.Input.Path
            /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether any items inside the shared drive should also be deleted. This option is only supported when `useDomainAdminAccess` is also set to `true`.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/allowItemDeletion`.
                public var allowItemDeletion: Swift.Bool?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/DELETE/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - allowItemDeletion: Whether any items inside the shared drive should also be deleted. This option is only supported when `useDomainAdminAccess` is also set to `true`.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    allowItemDeletion: Swift.Bool? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.allowItemDeletion = allowItemDeletion
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_drives_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_drives_delete.Input.Path,
                query: Operations.Drive_drives_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/{driveId}/delete(drive.drives.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/{driveId}/delete(drive.drives.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Hides a shared drive from the default view.
    ///
    /// - Remark: HTTP `POST /drives/{driveId}/hide`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/hide/post(drive.drives.hide)`.
    public enum Drive_drives_hide {
        public static let id: Swift.String = "drive.drives.hide"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the shared drive.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/path/driveId`.
                public var driveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - driveId: The ID of the shared drive.
                public init(driveId: Swift.String) {
                    self.driveId = driveId
                }
            }
            public var path: Operations.Drive_drives_hide.Input.Path
            /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_drives_hide.Input.Query
            /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_hide.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_hide.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_drives_hide.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_drives_hide.Input.Path,
                query: Operations.Drive_drives_hide.Input.Query = .init(),
                headers: Operations.Drive_drives_hide.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/drives/{driveId}/hide/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Drive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Drive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_drives_hide.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_drives_hide.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/{driveId}/hide/post(drive.drives.hide)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_hide.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_hide.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Restores a shared drive to the default view.
    ///
    /// - Remark: HTTP `POST /drives/{driveId}/unhide`.
    /// - Remark: Generated from `#/paths//drives/{driveId}/unhide/post(drive.drives.unhide)`.
    public enum Drive_drives_unhide {
        public static let id: Swift.String = "drive.drives.unhide"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the shared drive.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/path/driveId`.
                public var driveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - driveId: The ID of the shared drive.
                public init(driveId: Swift.String) {
                    self.driveId = driveId
                }
            }
            public var path: Operations.Drive_drives_unhide.Input.Path
            /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_drives_unhide.Input.Query
            /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_unhide.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_drives_unhide.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_drives_unhide.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_drives_unhide.Input.Path,
                query: Operations.Drive_drives_unhide.Input.Query = .init(),
                headers: Operations.Drive_drives_unhide.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/drives/{driveId}/unhide/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Drive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Drive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_drives_unhide.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_drives_unhide.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//drives/{driveId}/unhide/post(drive.drives.unhide)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_drives_unhide.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_drives_unhide.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    ///  Lists the user's files. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for files & folders](/drive/api/guides/search-files) guide. *Note:* This method returns *all* files by default, including trashed files. If you don't want trashed files to appear in the list, use the `trashed=false` query parameter to remove trashed files from the results.
    ///
    /// - Remark: HTTP `GET /files`.
    /// - Remark: Generated from `#/paths//files/get(drive.files.list)`.
    public enum Drive_files_list {
        public static let id: Swift.String = "drive.files.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Bodies of items (files/documents) to which the query applies. Supported bodies are 'user', 'domain', 'drive', and 'allDrives'. Prefer 'user' or 'drive' to 'allDrives' for efficiency. By default, corpora is set to 'user'. However, this can change depending on the filter set through the 'q' parameter.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/corpora`.
                public var corpora: Swift.String?
                /// - Remark: Generated from `#/paths/files/GET/query/corpus`.
                @frozen public enum CorpusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case domain = "domain"
                    case user = "user"
                }
                /// Deprecated: The source of files to list. Use 'corpora' instead.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/corpus`.
                public var corpus: Operations.Drive_files_list.Input.Query.CorpusPayload?
                /// ID of the shared drive to search.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/driveId`.
                public var driveId: Swift.String?
                /// Whether both My Drive and shared drive items should be included in results.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/includeItemsFromAllDrives`.
                public var includeItemsFromAllDrives: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Deprecated: Use `includeItemsFromAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/includeTeamDriveItems`.
                public var includeTeamDriveItems: Swift.Bool?
                /// A comma-separated list of sort keys. Valid keys are 'createdTime', 'folder', 'modifiedByMeTime', 'modifiedTime', 'name', 'name_natural', 'quotaBytesUsed', 'recency', 'sharedWithMeTime', 'starred', and 'viewedByMeTime'. Each key sorts ascending by default, but can be reversed with the 'desc' modifier. Example usage: ?orderBy=folder,modifiedTime desc,name.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/orderBy`.
                public var orderBy: Swift.String?
                /// The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// A query for filtering the file results. See the "Search for files & folders" guide for supported syntax.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/q`.
                public var q: Swift.String?
                /// A comma-separated list of spaces to query within the corpora. Supported values are 'drive' and 'appDataFolder'.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/spaces`.
                public var spaces: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Deprecated: Use `driveId` instead.
                ///
                /// - Remark: Generated from `#/paths/files/GET/query/teamDriveId`.
                public var teamDriveId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - corpora: Bodies of items (files/documents) to which the query applies. Supported bodies are 'user', 'domain', 'drive', and 'allDrives'. Prefer 'user' or 'drive' to 'allDrives' for efficiency. By default, corpora is set to 'user'. However, this can change depending on the filter set through the 'q' parameter.
                ///   - corpus: Deprecated: The source of files to list. Use 'corpora' instead.
                ///   - driveId: ID of the shared drive to search.
                ///   - includeItemsFromAllDrives: Whether both My Drive and shared drive items should be included in results.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - includeTeamDriveItems: Deprecated: Use `includeItemsFromAllDrives` instead.
                ///   - orderBy: A comma-separated list of sort keys. Valid keys are 'createdTime', 'folder', 'modifiedByMeTime', 'modifiedTime', 'name', 'name_natural', 'quotaBytesUsed', 'recency', 'sharedWithMeTime', 'starred', and 'viewedByMeTime'. Each key sorts ascending by default, but can be reversed with the 'desc' modifier. Example usage: ?orderBy=folder,modifiedTime desc,name.
                ///   - pageSize: The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///   - q: A query for filtering the file results. See the "Search for files & folders" guide for supported syntax.
                ///   - spaces: A comma-separated list of spaces to query within the corpora. Supported values are 'drive' and 'appDataFolder'.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - teamDriveId: Deprecated: Use `driveId` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    corpora: Swift.String? = nil,
                    corpus: Operations.Drive_files_list.Input.Query.CorpusPayload? = nil,
                    driveId: Swift.String? = nil,
                    includeItemsFromAllDrives: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    includeTeamDriveItems: Swift.Bool? = nil,
                    orderBy: Swift.String? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil,
                    q: Swift.String? = nil,
                    spaces: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    teamDriveId: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.corpora = corpora
                    self.corpus = corpus
                    self.driveId = driveId
                    self.includeItemsFromAllDrives = includeItemsFromAllDrives
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.includeTeamDriveItems = includeTeamDriveItems
                    self.orderBy = orderBy
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                    self.q = q
                    self.spaces = spaces
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.teamDriveId = teamDriveId
                }
            }
            public var query: Operations.Drive_files_list.Input.Query
            /// - Remark: Generated from `#/paths/files/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_files_list.Input.Query = .init(),
                headers: Operations.Drive_files_list.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.FileList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FileList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/get(drive.files.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    ///  Creates a new file. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads). Apps creating shortcuts with `files.create` must specify the MIME type `application/vnd.google-apps.shortcut`. Apps should specify a file extension in the `name` property when inserting files with the API. For example, an operation to insert a JPEG file should specify something like `"name": "cat.jpg"` in the metadata. Subsequent `GET` requests include the read-only `fileExtension` property populated with the extension originally specified in the `title` property. When a Google Drive user requests to download a file, or when the file is downloaded through the sync client, Drive builds a full filename (with extension) based on the title. In cases where the extension is missing, Drive attempts to determine the extension based on the file's MIME type.
    ///
    /// - Remark: HTTP `POST /files`.
    /// - Remark: Generated from `#/paths//files/post(drive.files.create)`.
    public enum Drive_files_create {
        public static let id: Swift.String = "drive.files.create"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Deprecated. Creating files in multiple folders is no longer supported.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/enforceSingleParent`.
                public var enforceSingleParent: Swift.Bool?
                /// Whether to ignore the domain's default visibility settings for the created file. Domain administrators can choose to make all uploaded files visible to the domain by default; this parameter bypasses that behavior for the request. Permissions are still inherited from parent folders.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/ignoreDefaultVisibility`.
                public var ignoreDefaultVisibility: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether to set the 'keepForever' field in the new head revision. This is only applicable to files with binary content in Google Drive. Only 200 revisions for the file can be kept forever. If the limit is reached, try deleting pinned revisions.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/keepRevisionForever`.
                public var keepRevisionForever: Swift.Bool?
                /// A language hint for OCR processing during image import (ISO 639-1 code).
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/ocrLanguage`.
                public var ocrLanguage: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Whether to use the uploaded content as indexable text.
                ///
                /// - Remark: Generated from `#/paths/files/POST/query/useContentAsIndexableText`.
                public var useContentAsIndexableText: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - enforceSingleParent: Deprecated. Creating files in multiple folders is no longer supported.
                ///   - ignoreDefaultVisibility: Whether to ignore the domain's default visibility settings for the created file. Domain administrators can choose to make all uploaded files visible to the domain by default; this parameter bypasses that behavior for the request. Permissions are still inherited from parent folders.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - keepRevisionForever: Whether to set the 'keepForever' field in the new head revision. This is only applicable to files with binary content in Google Drive. Only 200 revisions for the file can be kept forever. If the limit is reached, try deleting pinned revisions.
                ///   - ocrLanguage: A language hint for OCR processing during image import (ISO 639-1 code).
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - useContentAsIndexableText: Whether to use the uploaded content as indexable text.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    enforceSingleParent: Swift.Bool? = nil,
                    ignoreDefaultVisibility: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    keepRevisionForever: Swift.Bool? = nil,
                    ocrLanguage: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    useContentAsIndexableText: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.enforceSingleParent = enforceSingleParent
                    self.ignoreDefaultVisibility = ignoreDefaultVisibility
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.keepRevisionForever = keepRevisionForever
                    self.ocrLanguage = ocrLanguage
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.useContentAsIndexableText = useContentAsIndexableText
                }
            }
            public var query: Operations.Drive_files_create.Input.Query
            /// - Remark: Generated from `#/paths/files/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_create.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_create.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_create.Input.Headers
            /// - Remark: Generated from `#/paths/files/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/POST/requestBody/content/application\/octet-stream`.
                case binary(OpenAPIRuntime.HTTPBody)
            }
            public var body: Operations.Drive_files_create.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                query: Operations.Drive_files_create.Input.Query = .init(),
                headers: Operations.Drive_files_create.Input.Headers = .init(),
                body: Operations.Drive_files_create.Input.Body? = nil
            ) {
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.File)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.File {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_create.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_create.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/post(drive.files.create)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_create.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_create.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Generates a set of file IDs which can be provided in create or copy requests.
    ///
    /// - Remark: HTTP `GET /files/generateIds`.
    /// - Remark: Generated from `#/paths//files/generateIds/get(drive.files.generateIds)`.
    public enum Drive_files_generateIds {
        public static let id: Swift.String = "drive.files.generateIds"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/generateIds/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// The number of IDs to return.
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/count`.
                public var count: Swift.Int?
                /// The space in which the IDs can be used to create new files. Supported values are 'drive' and 'appDataFolder'. (Default: 'drive')
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/space`.
                public var space: Swift.String?
                /// The type of items which the IDs can be used for. Supported values are 'files' and 'shortcuts'. Note that 'shortcuts' are only supported in the `drive` 'space'. (Default: 'files')
                ///
                /// - Remark: Generated from `#/paths/files/generateIds/GET/query/type`.
                public var _type: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - count: The number of IDs to return.
                ///   - space: The space in which the IDs can be used to create new files. Supported values are 'drive' and 'appDataFolder'. (Default: 'drive')
                ///   - _type: The type of items which the IDs can be used for. Supported values are 'files' and 'shortcuts'. Note that 'shortcuts' are only supported in the `drive` 'space'. (Default: 'files')
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    count: Swift.Int? = nil,
                    space: Swift.String? = nil,
                    _type: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.count = count
                    self.space = space
                    self._type = _type
                }
            }
            public var query: Operations.Drive_files_generateIds.Input.Query
            /// - Remark: Generated from `#/paths/files/generateIds/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_generateIds.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_generateIds.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_generateIds.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_files_generateIds.Input.Query = .init(),
                headers: Operations.Drive_files_generateIds.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/generateIds/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/generateIds/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.GeneratedIds)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.GeneratedIds {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_generateIds.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_generateIds.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/generateIds/get(drive.files.generateIds)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_generateIds.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_generateIds.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Permanently deletes all of the user's trashed files.
    ///
    /// - Remark: HTTP `DELETE /files/trash`.
    /// - Remark: Generated from `#/paths//files/trash/delete(drive.files.emptyTrash)`.
    public enum Drive_files_emptyTrash {
        public static let id: Swift.String = "drive.files.emptyTrash"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/trash/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// If set, empties the trash of the provided shared drive.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/driveId`.
                public var driveId: Swift.String?
                /// Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item will be placed under its owner's root.
                ///
                /// - Remark: Generated from `#/paths/files/trash/DELETE/query/enforceSingleParent`.
                public var enforceSingleParent: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - driveId: If set, empties the trash of the provided shared drive.
                ///   - enforceSingleParent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item will be placed under its owner's root.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    driveId: Swift.String? = nil,
                    enforceSingleParent: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.driveId = driveId
                    self.enforceSingleParent = enforceSingleParent
                }
            }
            public var query: Operations.Drive_files_emptyTrash.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            public init(query: Operations.Drive_files_emptyTrash.Input.Query = .init()) {
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/trash/delete(drive.files.emptyTrash)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_emptyTrash.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/trash/delete(drive.files.emptyTrash)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_emptyTrash.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    ///  Gets a file's metadata or content by ID. If you provide the URL parameter `alt=media`, then the response includes the file contents in the response body. Downloading content with `alt=media` only works if the file is stored in Drive. To download Google Docs, Sheets, and Slides use [`files.export`](/drive/api/reference/rest/v3/files/export) instead. For more information, see [Download & export files](/drive/api/guides/manage-downloads).
    ///
    /// - Remark: HTTP `GET /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/get(drive.files.get)`.
    public enum Drive_files_get {
        public static let id: Swift.String = "drive.files.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_get.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether the user is acknowledging the risk of downloading known malware or other abusive files. This is only applicable when alt=media.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/acknowledgeAbuse`.
                public var acknowledgeAbuse: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - acknowledgeAbuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files. This is only applicable when alt=media.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    acknowledgeAbuse: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.acknowledgeAbuse = acknowledgeAbuse
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                }
            }
            public var query: Operations.Drive_files_get.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_files_get.Input.Path,
                query: Operations.Drive_files_get.Input.Query = .init(),
                headers: Operations.Drive_files_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.File)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.File {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/get(drive.files.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    ///  Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as `modifiedDate`. This method supports patch semantics. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads).
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/patch(drive.files.update)`.
    public enum Drive_files_update {
        public static let id: Swift.String = "drive.files.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_update.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// A comma-separated list of parent IDs to add.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/addParents`.
                public var addParents: Swift.String?
                /// Deprecated: Adding files to multiple folders is no longer supported. Use shortcuts instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/enforceSingleParent`.
                public var enforceSingleParent: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether to set the 'keepForever' field in the new head revision. This is only applicable to files with binary content in Google Drive. Only 200 revisions for the file can be kept forever. If the limit is reached, try deleting pinned revisions.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/keepRevisionForever`.
                public var keepRevisionForever: Swift.Bool?
                /// A language hint for OCR processing during image import (ISO 639-1 code).
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/ocrLanguage`.
                public var ocrLanguage: Swift.String?
                /// A comma-separated list of parent IDs to remove.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/removeParents`.
                public var removeParents: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Whether to use the uploaded content as indexable text.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/query/useContentAsIndexableText`.
                public var useContentAsIndexableText: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - addParents: A comma-separated list of parent IDs to add.
                ///   - enforceSingleParent: Deprecated: Adding files to multiple folders is no longer supported. Use shortcuts instead.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - keepRevisionForever: Whether to set the 'keepForever' field in the new head revision. This is only applicable to files with binary content in Google Drive. Only 200 revisions for the file can be kept forever. If the limit is reached, try deleting pinned revisions.
                ///   - ocrLanguage: A language hint for OCR processing during image import (ISO 639-1 code).
                ///   - removeParents: A comma-separated list of parent IDs to remove.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - useContentAsIndexableText: Whether to use the uploaded content as indexable text.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    addParents: Swift.String? = nil,
                    enforceSingleParent: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    keepRevisionForever: Swift.Bool? = nil,
                    ocrLanguage: Swift.String? = nil,
                    removeParents: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    useContentAsIndexableText: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.addParents = addParents
                    self.enforceSingleParent = enforceSingleParent
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.keepRevisionForever = keepRevisionForever
                    self.ocrLanguage = ocrLanguage
                    self.removeParents = removeParents
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.useContentAsIndexableText = useContentAsIndexableText
                }
            }
            public var query: Operations.Drive_files_update.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_update.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/requestBody/content/application\/octet-stream`.
                case binary(OpenAPIRuntime.HTTPBody)
            }
            public var body: Operations.Drive_files_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_files_update.Input.Path,
                query: Operations.Drive_files_update.Input.Query = .init(),
                headers: Operations.Drive_files_update.Input.Headers = .init(),
                body: Operations.Drive_files_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.File)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.File {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/patch(drive.files.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive, the user must be an `organizer` on the parent folder. If the target is a folder, all descendants owned by the user are also deleted.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/delete(drive.files.delete)`.
    public enum Drive_files_delete {
        public static let id: Swift.String = "drive.files.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_delete.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item will be placed under its owner's root.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/enforceSingleParent`.
                public var enforceSingleParent: Swift.Bool?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/DELETE/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - enforceSingleParent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item will be placed under its owner's root.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    enforceSingleParent: Swift.Bool? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.enforceSingleParent = enforceSingleParent
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                }
            }
            public var query: Operations.Drive_files_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_files_delete.Input.Path,
                query: Operations.Drive_files_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/delete(drive.files.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/delete(drive.files.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Lists a file's comments.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/get(drive.comments.list)`.
    public enum Drive_comments_list {
        public static let id: Swift.String = "drive.comments.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_comments_list.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether to include deleted comments. Deleted comments will not include their original content.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/includeDeleted`.
                public var includeDeleted: Swift.Bool?
                /// The maximum number of comments to return per page.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// The minimum value of 'modifiedTime' for the result comments (RFC 3339 date-time).
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/query/startModifiedTime`.
                public var startModifiedTime: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - includeDeleted: Whether to include deleted comments. Deleted comments will not include their original content.
                ///   - pageSize: The maximum number of comments to return per page.
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///   - startModifiedTime: The minimum value of 'modifiedTime' for the result comments (RFC 3339 date-time).
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    includeDeleted: Swift.Bool? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil,
                    startModifiedTime: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.includeDeleted = includeDeleted
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                    self.startModifiedTime = startModifiedTime
                }
            }
            public var query: Operations.Drive_comments_list.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_comments_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_comments_list.Input.Path,
                query: Operations.Drive_comments_list.Input.Query = .init(),
                headers: Operations.Drive_comments_list.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CommentList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CommentList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_comments_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_comments_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/get(drive.comments.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_comments_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_comments_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Creates a comment on a file.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/comments`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/post(drive.comments.create)`.
    public enum Drive_comments_create {
        public static let id: Swift.String = "drive.comments.create"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_comments_create.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_comments_create.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_create.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_create.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_comments_create.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Comment)
            }
            public var body: Operations.Drive_comments_create.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_comments_create.Input.Path,
                query: Operations.Drive_comments_create.Input.Query = .init(),
                headers: Operations.Drive_comments_create.Input.Headers = .init(),
                body: Operations.Drive_comments_create.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Comment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Comment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_comments_create.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_comments_create.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/post(drive.comments.create)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_comments_create.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_comments_create.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets a comment by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/get(drive.comments.get)`.
    public enum Drive_comments_get {
        public static let id: Swift.String = "drive.comments.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/path/commentId`.
                public var commentId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                }
            }
            public var path: Operations.Drive_comments_get.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether to return deleted comments. Deleted comments will not include their original content.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/query/includeDeleted`.
                public var includeDeleted: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - includeDeleted: Whether to return deleted comments. Deleted comments will not include their original content.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    includeDeleted: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.includeDeleted = includeDeleted
                }
            }
            public var query: Operations.Drive_comments_get.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_comments_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_comments_get.Input.Path,
                query: Operations.Drive_comments_get.Input.Query = .init(),
                headers: Operations.Drive_comments_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Comment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Comment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_comments_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_comments_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/get(drive.comments.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_comments_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_comments_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Updates a comment with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/patch(drive.comments.update)`.
    public enum Drive_comments_update {
        public static let id: Swift.String = "drive.comments.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/path/commentId`.
                public var commentId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                }
            }
            public var path: Operations.Drive_comments_update.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_comments_update.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_comments_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_comments_update.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/requestBody/content/application\/json`.
                case json(Components.Schemas.Comment)
            }
            public var body: Operations.Drive_comments_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_comments_update.Input.Path,
                query: Operations.Drive_comments_update.Input.Query = .init(),
                headers: Operations.Drive_comments_update.Input.Headers = .init(),
                body: Operations.Drive_comments_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Comment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Comment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_comments_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_comments_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/patch(drive.comments.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_comments_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_comments_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deletes a comment.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/comments/{commentId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/delete(drive.comments.delete)`.
    public enum Drive_comments_delete {
        public static let id: Swift.String = "drive.comments.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/path/commentId`.
                public var commentId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                }
            }
            public var path: Operations.Drive_comments_delete.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_comments_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_comments_delete.Input.Path,
                query: Operations.Drive_comments_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/delete(drive.comments.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_comments_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/delete(drive.comments.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_comments_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Lists a comment's replies.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}/replies`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/get(drive.replies.list)`.
    public enum Drive_replies_list {
        public static let id: Swift.String = "drive.replies.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/path/commentId`.
                public var commentId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                }
            }
            public var path: Operations.Drive_replies_list.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether to include deleted replies. Deleted replies will not include their original content.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/includeDeleted`.
                public var includeDeleted: Swift.Bool?
                /// The maximum number of replies to return per page.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - includeDeleted: Whether to include deleted replies. Deleted replies will not include their original content.
                ///   - pageSize: The maximum number of replies to return per page.
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    includeDeleted: Swift.Bool? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.includeDeleted = includeDeleted
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                }
            }
            public var query: Operations.Drive_replies_list.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_replies_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_replies_list.Input.Path,
                query: Operations.Drive_replies_list.Input.Query = .init(),
                headers: Operations.Drive_replies_list.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ReplyList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ReplyList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_replies_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_replies_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/get(drive.replies.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_replies_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_replies_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Creates a reply to a comment.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/comments/{commentId}/replies`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/post(drive.replies.create)`.
    public enum Drive_replies_create {
        public static let id: Swift.String = "drive.replies.create"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/path/commentId`.
                public var commentId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                }
            }
            public var path: Operations.Drive_replies_create.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_replies_create.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_create.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_create.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_replies_create.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Reply)
            }
            public var body: Operations.Drive_replies_create.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_replies_create.Input.Path,
                query: Operations.Drive_replies_create.Input.Query = .init(),
                headers: Operations.Drive_replies_create.Input.Headers = .init(),
                body: Operations.Drive_replies_create.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Reply)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Reply {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_replies_create.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_replies_create.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/post(drive.replies.create)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_replies_create.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_replies_create.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets a reply by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/get(drive.replies.get)`.
    public enum Drive_replies_get {
        public static let id: Swift.String = "drive.replies.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/path/commentId`.
                public var commentId: Swift.String
                /// The ID of the reply.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/path/replyId`.
                public var replyId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                ///   - replyId: The ID of the reply.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String,
                    replyId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                    self.replyId = replyId
                }
            }
            public var path: Operations.Drive_replies_get.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether to return deleted replies. Deleted replies will not include their original content.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/query/includeDeleted`.
                public var includeDeleted: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - includeDeleted: Whether to return deleted replies. Deleted replies will not include their original content.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    includeDeleted: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.includeDeleted = includeDeleted
                }
            }
            public var query: Operations.Drive_replies_get.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_replies_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_replies_get.Input.Path,
                query: Operations.Drive_replies_get.Input.Query = .init(),
                headers: Operations.Drive_replies_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Reply)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Reply {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_replies_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_replies_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/get(drive.replies.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_replies_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_replies_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Updates a reply with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/patch(drive.replies.update)`.
    public enum Drive_replies_update {
        public static let id: Swift.String = "drive.replies.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/path/commentId`.
                public var commentId: Swift.String
                /// The ID of the reply.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/path/replyId`.
                public var replyId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                ///   - replyId: The ID of the reply.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String,
                    replyId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                    self.replyId = replyId
                }
            }
            public var path: Operations.Drive_replies_update.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_replies_update.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_replies_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_replies_update.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/requestBody/content/application\/json`.
                case json(Components.Schemas.Reply)
            }
            public var body: Operations.Drive_replies_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_replies_update.Input.Path,
                query: Operations.Drive_replies_update.Input.Query = .init(),
                headers: Operations.Drive_replies_update.Input.Headers = .init(),
                body: Operations.Drive_replies_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Reply)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Reply {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_replies_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_replies_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/patch(drive.replies.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_replies_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_replies_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deletes a reply.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/comments/{commentId}/replies/{replyId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/delete(drive.replies.delete)`.
    public enum Drive_replies_delete {
        public static let id: Swift.String = "drive.replies.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the comment.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/path/commentId`.
                public var commentId: Swift.String
                /// The ID of the reply.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/path/replyId`.
                public var replyId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - commentId: The ID of the comment.
                ///   - replyId: The ID of the reply.
                public init(
                    fileId: Swift.String,
                    commentId: Swift.String,
                    replyId: Swift.String
                ) {
                    self.fileId = fileId
                    self.commentId = commentId
                    self.replyId = replyId
                }
            }
            public var path: Operations.Drive_replies_delete.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/comments/{commentId}/replies/{replyId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_replies_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_replies_delete.Input.Path,
                query: Operations.Drive_replies_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/delete(drive.replies.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_replies_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/comments/{commentId}/replies/{replyId}/delete(drive.replies.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_replies_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Creates a copy of a file and applies any requested updates with patch semantics.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/copy`.
    /// - Remark: Generated from `#/paths//files/{fileId}/copy/post(drive.files.copy)`.
    public enum Drive_files_copy {
        public static let id: Swift.String = "drive.files.copy"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_copy.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Deprecated. Copying files into multiple folders is no longer supported. Use shortcuts instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/enforceSingleParent`.
                public var enforceSingleParent: Swift.Bool?
                /// Whether to ignore the domain's default visibility settings for the created file. Domain administrators can choose to make all uploaded files visible to the domain by default; this parameter bypasses that behavior for the request. Permissions are still inherited from parent folders.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/ignoreDefaultVisibility`.
                public var ignoreDefaultVisibility: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether to set the 'keepForever' field in the new head revision. This is only applicable to files with binary content in Google Drive. Only 200 revisions for the file can be kept forever. If the limit is reached, try deleting pinned revisions.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/keepRevisionForever`.
                public var keepRevisionForever: Swift.Bool?
                /// A language hint for OCR processing during image import (ISO 639-1 code).
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/ocrLanguage`.
                public var ocrLanguage: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - enforceSingleParent: Deprecated. Copying files into multiple folders is no longer supported. Use shortcuts instead.
                ///   - ignoreDefaultVisibility: Whether to ignore the domain's default visibility settings for the created file. Domain administrators can choose to make all uploaded files visible to the domain by default; this parameter bypasses that behavior for the request. Permissions are still inherited from parent folders.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - keepRevisionForever: Whether to set the 'keepForever' field in the new head revision. This is only applicable to files with binary content in Google Drive. Only 200 revisions for the file can be kept forever. If the limit is reached, try deleting pinned revisions.
                ///   - ocrLanguage: A language hint for OCR processing during image import (ISO 639-1 code).
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    enforceSingleParent: Swift.Bool? = nil,
                    ignoreDefaultVisibility: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    keepRevisionForever: Swift.Bool? = nil,
                    ocrLanguage: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.enforceSingleParent = enforceSingleParent
                    self.ignoreDefaultVisibility = ignoreDefaultVisibility
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.keepRevisionForever = keepRevisionForever
                    self.ocrLanguage = ocrLanguage
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                }
            }
            public var query: Operations.Drive_files_copy.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_copy.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_copy.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_copy.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.File)
            }
            public var body: Operations.Drive_files_copy.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_files_copy.Input.Path,
                query: Operations.Drive_files_copy.Input.Query = .init(),
                headers: Operations.Drive_files_copy.Input.Headers = .init(),
                body: Operations.Drive_files_copy.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/copy/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.File)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.File {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_copy.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_copy.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/copy/post(drive.files.copy)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_copy.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_copy.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/export`.
    /// - Remark: Generated from `#/paths//files/{fileId}/export/get(drive.files.export)`.
    public enum Drive_files_export {
        public static let id: Swift.String = "drive.files.export"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_export.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Required. The MIME type of the format requested for this export.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/export/GET/query/mimeType`.
                public var mimeType: Swift.String
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - mimeType: Required. The MIME type of the format requested for this export.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    mimeType: Swift.String
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.mimeType = mimeType
                }
            }
            public var query: Operations.Drive_files_export.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_files_export.Input.Path,
                query: Operations.Drive_files_export.Input.Query
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/export/get(drive.files.export)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_export.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/export/get(drive.files.export)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_export.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Lists the labels on a file.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/listLabels`.
    /// - Remark: Generated from `#/paths//files/{fileId}/listLabels/get(drive.files.listLabels)`.
    public enum Drive_files_listLabels {
        public static let id: Swift.String = "drive.files.listLabels"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID for the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID for the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_listLabels.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// The maximum number of labels to return per page. When not set, defaults to 100.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/maxResults`.
                public var maxResults: Swift.Int?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - maxResults: The maximum number of labels to return per page. When not set, defaults to 100.
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    maxResults: Swift.Int? = nil,
                    pageToken: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.maxResults = maxResults
                    self.pageToken = pageToken
                }
            }
            public var query: Operations.Drive_files_listLabels.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_listLabels.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_listLabels.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_listLabels.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_files_listLabels.Input.Path,
                query: Operations.Drive_files_listLabels.Input.Query = .init(),
                headers: Operations.Drive_files_listLabels.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/listLabels/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.LabelList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.LabelList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_listLabels.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_listLabels.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/listLabels/get(drive.files.listLabels)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_listLabels.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_listLabels.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Modifies the set of labels applied to a file. Returns a list of the labels that were added or modified.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/modifyLabels`.
    /// - Remark: Generated from `#/paths//files/{fileId}/modifyLabels/post(drive.files.modifyLabels)`.
    public enum Drive_files_modifyLabels {
        public static let id: Swift.String = "drive.files.modifyLabels"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file to which the labels belong.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file to which the labels belong.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_modifyLabels.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_files_modifyLabels.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_modifyLabels.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_modifyLabels.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_modifyLabels.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.ModifyLabelsRequest)
            }
            public var body: Operations.Drive_files_modifyLabels.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_files_modifyLabels.Input.Path,
                query: Operations.Drive_files_modifyLabels.Input.Query = .init(),
                headers: Operations.Drive_files_modifyLabels.Input.Headers = .init(),
                body: Operations.Drive_files_modifyLabels.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/modifyLabels/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ModifyLabelsResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ModifyLabelsResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_modifyLabels.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_modifyLabels.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/modifyLabels/post(drive.files.modifyLabels)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_modifyLabels.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_modifyLabels.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Lists a file's or shared drive's permissions.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/permissions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/get(drive.permissions.list)`.
    public enum Drive_permissions_list {
        public static let id: Swift.String = "drive.permissions.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file or shared drive.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file or shared drive.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_permissions_list.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// The maximum number of permissions to return per page. When not set for files in a shared drive, at most 100 results will be returned. When not set for files that are not in a shared drive, the entire list will be returned.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - pageSize: The maximum number of permissions to return per page. When not set for files in a shared drive, at most 100 results will be returned. When not set for files that are not in a shared drive, the entire list will be returned.
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.includePermissionsForView = includePermissionsForView
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_permissions_list.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_permissions_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_permissions_list.Input.Path,
                query: Operations.Drive_permissions_list.Input.Query = .init(),
                headers: Operations.Drive_permissions_list.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/permissions/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.PermissionList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PermissionList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_permissions_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_permissions_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/permissions/get(drive.permissions.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_permissions_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_permissions_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Creates a permission for a file or shared drive. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/permissions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/post(drive.permissions.create)`.
    public enum Drive_permissions_create {
        public static let id: Swift.String = "drive.permissions.create"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file or shared drive.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file or shared drive.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_permissions_create.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// A plain text custom message to include in the notification email.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/emailMessage`.
                public var emailMessage: Swift.String?
                /// Deprecated: See `moveToNewOwnersRoot` for details.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/enforceSingleParent`.
                public var enforceSingleParent: Swift.Bool?
                /// This parameter will only take effect if the item is not in a shared drive and the request is attempting to transfer the ownership of the item. If set to `true`, the item will be moved to the new owner's My Drive root folder and all prior parents removed. If set to `false`, parents are not changed.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/moveToNewOwnersRoot`.
                public var moveToNewOwnersRoot: Swift.Bool?
                /// Whether to send a notification email when sharing to users or groups. This defaults to true for users and groups, and is not allowed for other requests. It must not be disabled for ownership transfers.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/sendNotificationEmail`.
                public var sendNotificationEmail: Swift.Bool?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Whether to transfer ownership to the specified user and downgrade the current owner to a writer. This parameter is required as an acknowledgement of the side effect.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/transferOwnership`.
                public var transferOwnership: Swift.Bool?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - emailMessage: A plain text custom message to include in the notification email.
                ///   - enforceSingleParent: Deprecated: See `moveToNewOwnersRoot` for details.
                ///   - moveToNewOwnersRoot: This parameter will only take effect if the item is not in a shared drive and the request is attempting to transfer the ownership of the item. If set to `true`, the item will be moved to the new owner's My Drive root folder and all prior parents removed. If set to `false`, parents are not changed.
                ///   - sendNotificationEmail: Whether to send a notification email when sharing to users or groups. This defaults to true for users and groups, and is not allowed for other requests. It must not be disabled for ownership transfers.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - transferOwnership: Whether to transfer ownership to the specified user and downgrade the current owner to a writer. This parameter is required as an acknowledgement of the side effect.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    emailMessage: Swift.String? = nil,
                    enforceSingleParent: Swift.Bool? = nil,
                    moveToNewOwnersRoot: Swift.Bool? = nil,
                    sendNotificationEmail: Swift.Bool? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    transferOwnership: Swift.Bool? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.emailMessage = emailMessage
                    self.enforceSingleParent = enforceSingleParent
                    self.moveToNewOwnersRoot = moveToNewOwnersRoot
                    self.sendNotificationEmail = sendNotificationEmail
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.transferOwnership = transferOwnership
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_permissions_create.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_create.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_create.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_permissions_create.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Permission)
            }
            public var body: Operations.Drive_permissions_create.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_permissions_create.Input.Path,
                query: Operations.Drive_permissions_create.Input.Query = .init(),
                headers: Operations.Drive_permissions_create.Input.Headers = .init(),
                body: Operations.Drive_permissions_create.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/permissions/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Permission)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Permission {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_permissions_create.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_permissions_create.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/permissions/post(drive.permissions.create)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_permissions_create.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_permissions_create.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets a permission by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/get(drive.permissions.get)`.
    public enum Drive_permissions_get {
        public static let id: Swift.String = "drive.permissions.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the permission.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/path/permissionId`.
                public var permissionId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - permissionId: The ID of the permission.
                public init(
                    fileId: Swift.String,
                    permissionId: Swift.String
                ) {
                    self.fileId = fileId
                    self.permissionId = permissionId
                }
            }
            public var path: Operations.Drive_permissions_get.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_permissions_get.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_permissions_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_permissions_get.Input.Path,
                query: Operations.Drive_permissions_get.Input.Query = .init(),
                headers: Operations.Drive_permissions_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Permission)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Permission {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_permissions_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_permissions_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/get(drive.permissions.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_permissions_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_permissions_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Updates a permission with patch semantics. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/patch(drive.permissions.update)`.
    public enum Drive_permissions_update {
        public static let id: Swift.String = "drive.permissions.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file or shared drive.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the permission.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/path/permissionId`.
                public var permissionId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file or shared drive.
                ///   - permissionId: The ID of the permission.
                public init(
                    fileId: Swift.String,
                    permissionId: Swift.String
                ) {
                    self.fileId = fileId
                    self.permissionId = permissionId
                }
            }
            public var path: Operations.Drive_permissions_update.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether to remove the expiration date.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/removeExpiration`.
                public var removeExpiration: Swift.Bool?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Whether to transfer ownership to the specified user and downgrade the current owner to a writer. This parameter is required as an acknowledgement of the side effect.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/transferOwnership`.
                public var transferOwnership: Swift.Bool?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - removeExpiration: Whether to remove the expiration date.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - transferOwnership: Whether to transfer ownership to the specified user and downgrade the current owner to a writer. This parameter is required as an acknowledgement of the side effect.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    removeExpiration: Swift.Bool? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    transferOwnership: Swift.Bool? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.removeExpiration = removeExpiration
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.transferOwnership = transferOwnership
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_permissions_update.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_permissions_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_permissions_update.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/requestBody/content/application\/json`.
                case json(Components.Schemas.Permission)
            }
            public var body: Operations.Drive_permissions_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_permissions_update.Input.Path,
                query: Operations.Drive_permissions_update.Input.Query = .init(),
                headers: Operations.Drive_permissions_update.Input.Headers = .init(),
                body: Operations.Drive_permissions_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Permission)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Permission {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_permissions_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_permissions_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/patch(drive.permissions.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_permissions_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_permissions_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deletes a permission. **Warning:** Concurrent permissions operations on the same file are not supported; only the last update is applied.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/permissions/{permissionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/delete(drive.permissions.delete)`.
    public enum Drive_permissions_delete {
        public static let id: Swift.String = "drive.permissions.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file or shared drive.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the permission.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/path/permissionId`.
                public var permissionId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file or shared drive.
                ///   - permissionId: The ID of the permission.
                public init(
                    fileId: Swift.String,
                    permissionId: Swift.String
                ) {
                    self.fileId = fileId
                    self.permissionId = permissionId
                }
            }
            public var path: Operations.Drive_permissions_delete.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/permissions/{permissionId}/DELETE/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_permissions_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_permissions_delete.Input.Path,
                query: Operations.Drive_permissions_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/delete(drive.permissions.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_permissions_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/permissions/{permissionId}/delete(drive.permissions.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_permissions_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Lists a file's revisions.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/revisions`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/get(drive.revisions.list)`.
    public enum Drive_revisions_list {
        public static let id: Swift.String = "drive.revisions.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_revisions_list.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// The maximum number of revisions to return per page.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - pageSize: The maximum number of revisions to return per page.
                ///   - pageToken: The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                }
            }
            public var query: Operations.Drive_revisions_list.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_revisions_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_revisions_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_revisions_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_revisions_list.Input.Path,
                query: Operations.Drive_revisions_list.Input.Query = .init(),
                headers: Operations.Drive_revisions_list.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/revisions/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RevisionList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RevisionList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_revisions_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_revisions_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/revisions/get(drive.revisions.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_revisions_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_revisions_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets a revision's metadata or content by ID.
    ///
    /// - Remark: HTTP `GET /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/get(drive.revisions.get)`.
    public enum Drive_revisions_get {
        public static let id: Swift.String = "drive.revisions.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the revision.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/path/revisionId`.
                public var revisionId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - revisionId: The ID of the revision.
                public init(
                    fileId: Swift.String,
                    revisionId: Swift.String
                ) {
                    self.fileId = fileId
                    self.revisionId = revisionId
                }
            }
            public var path: Operations.Drive_revisions_get.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether the user is acknowledging the risk of downloading known malware or other abusive files. This is only applicable when alt=media.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/query/acknowledgeAbuse`.
                public var acknowledgeAbuse: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - acknowledgeAbuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files. This is only applicable when alt=media.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    acknowledgeAbuse: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.acknowledgeAbuse = acknowledgeAbuse
                }
            }
            public var query: Operations.Drive_revisions_get.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_revisions_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_revisions_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_revisions_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_revisions_get.Input.Path,
                query: Operations.Drive_revisions_get.Input.Query = .init(),
                headers: Operations.Drive_revisions_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Revision)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Revision {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_revisions_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_revisions_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/get(drive.revisions.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_revisions_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_revisions_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Updates a revision with patch semantics.
    ///
    /// - Remark: HTTP `PATCH /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/patch(drive.revisions.update)`.
    public enum Drive_revisions_update {
        public static let id: Swift.String = "drive.revisions.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the revision.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/path/revisionId`.
                public var revisionId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - revisionId: The ID of the revision.
                public init(
                    fileId: Swift.String,
                    revisionId: Swift.String
                ) {
                    self.fileId = fileId
                    self.revisionId = revisionId
                }
            }
            public var path: Operations.Drive_revisions_update.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_revisions_update.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_revisions_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_revisions_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_revisions_update.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/requestBody/content/application\/json`.
                case json(Components.Schemas.Revision)
            }
            public var body: Operations.Drive_revisions_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_revisions_update.Input.Path,
                query: Operations.Drive_revisions_update.Input.Query = .init(),
                headers: Operations.Drive_revisions_update.Input.Headers = .init(),
                body: Operations.Drive_revisions_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Revision)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Revision {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_revisions_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_revisions_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/patch(drive.revisions.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_revisions_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_revisions_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Permanently deletes a file version. You can only delete revisions for files with binary content in Google Drive, like images or videos. Revisions for other files, like Google Docs or Sheets, and the last remaining file version can't be deleted.
    ///
    /// - Remark: HTTP `DELETE /files/{fileId}/revisions/{revisionId}`.
    /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/delete(drive.revisions.delete)`.
    public enum Drive_revisions_delete {
        public static let id: Swift.String = "drive.revisions.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/path/fileId`.
                public var fileId: Swift.String
                /// The ID of the revision.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/path/revisionId`.
                public var revisionId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                ///   - revisionId: The ID of the revision.
                public init(
                    fileId: Swift.String,
                    revisionId: Swift.String
                ) {
                    self.fileId = fileId
                    self.revisionId = revisionId
                }
            }
            public var path: Operations.Drive_revisions_delete.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/revisions/{revisionId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_revisions_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_revisions_delete.Input.Path,
                query: Operations.Drive_revisions_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/delete(drive.revisions.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_revisions_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/revisions/{revisionId}/delete(drive.revisions.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_revisions_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Subscribes to changes to a file.
    ///
    /// - Remark: HTTP `POST /files/{fileId}/watch`.
    /// - Remark: Generated from `#/paths//files/{fileId}/watch/post(drive.files.watch)`.
    public enum Drive_files_watch {
        public static let id: Swift.String = "drive.files.watch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the file.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/path/fileId`.
                public var fileId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - fileId: The ID of the file.
                public init(fileId: Swift.String) {
                    self.fileId = fileId
                }
            }
            public var path: Operations.Drive_files_watch.Input.Path
            /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Whether the user is acknowledging the risk of downloading known malware or other abusive files. This is only applicable when alt=media.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/acknowledgeAbuse`.
                public var acknowledgeAbuse: Swift.Bool?
                /// A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/includeLabels`.
                public var includeLabels: Swift.String?
                /// Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/includePermissionsForView`.
                public var includePermissionsForView: Swift.String?
                /// Whether the requesting application supports both My Drives and shared drives.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/supportsAllDrives`.
                public var supportsAllDrives: Swift.Bool?
                /// Deprecated: Use `supportsAllDrives` instead.
                ///
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/query/supportsTeamDrives`.
                public var supportsTeamDrives: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - acknowledgeAbuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files. This is only applicable when alt=media.
                ///   - includeLabels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
                ///   - includePermissionsForView: Specifies which additional view's permissions to include in the response. Only 'published' is supported.
                ///   - supportsAllDrives: Whether the requesting application supports both My Drives and shared drives.
                ///   - supportsTeamDrives: Deprecated: Use `supportsAllDrives` instead.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    acknowledgeAbuse: Swift.Bool? = nil,
                    includeLabels: Swift.String? = nil,
                    includePermissionsForView: Swift.String? = nil,
                    supportsAllDrives: Swift.Bool? = nil,
                    supportsTeamDrives: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.acknowledgeAbuse = acknowledgeAbuse
                    self.includeLabels = includeLabels
                    self.includePermissionsForView = includePermissionsForView
                    self.supportsAllDrives = supportsAllDrives
                    self.supportsTeamDrives = supportsTeamDrives
                }
            }
            public var query: Operations.Drive_files_watch.Input.Query
            /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_watch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_files_watch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_files_watch.Input.Headers
            /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.Channel)
            }
            public var body: Operations.Drive_files_watch.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_files_watch.Input.Path,
                query: Operations.Drive_files_watch.Input.Query = .init(),
                headers: Operations.Drive_files_watch.Input.Headers = .init(),
                body: Operations.Drive_files_watch.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/files/{fileId}/watch/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.Channel)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Channel {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_files_watch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_files_watch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//files/{fileId}/watch/post(drive.files.watch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_files_watch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_files_watch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deprecated: Use `drives.list` instead.
    ///
    /// - Remark: HTTP `GET /teamdrives`.
    /// - Remark: Generated from `#/paths//teamdrives/get(drive.teamdrives.list)`.
    public enum Drive_teamdrives_list {
        public static let id: Swift.String = "drive.teamdrives.list"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/teamdrives/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Maximum number of Team Drives to return.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/pageSize`.
                public var pageSize: Swift.Int?
                /// Page token for Team Drives.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/pageToken`.
                public var pageToken: Swift.String?
                /// Query string for searching Team Drives.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/q`.
                public var q: Swift.String?
                /// Issue the request as a domain administrator; if set to true, then all Team Drives of the domain in which the requester is an administrator are returned.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/GET/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - pageSize: Maximum number of Team Drives to return.
                ///   - pageToken: Page token for Team Drives.
                ///   - q: Query string for searching Team Drives.
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then all Team Drives of the domain in which the requester is an administrator are returned.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    pageSize: Swift.Int? = nil,
                    pageToken: Swift.String? = nil,
                    q: Swift.String? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.pageSize = pageSize
                    self.pageToken = pageToken
                    self.q = q
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_teamdrives_list.Input.Query
            /// - Remark: Generated from `#/paths/teamdrives/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_list.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_list.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_teamdrives_list.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.Drive_teamdrives_list.Input.Query = .init(),
                headers: Operations.Drive_teamdrives_list.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/teamdrives/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/teamdrives/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.TeamDriveList)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TeamDriveList {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_teamdrives_list.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_teamdrives_list.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//teamdrives/get(drive.teamdrives.list)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_teamdrives_list.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_teamdrives_list.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deprecated: Use `drives.create` instead.
    ///
    /// - Remark: HTTP `POST /teamdrives`.
    /// - Remark: Generated from `#/paths//teamdrives/post(drive.teamdrives.create)`.
    public enum Drive_teamdrives_create {
        public static let id: Swift.String = "drive.teamdrives.create"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/teamdrives/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Required. An ID, such as a random UUID, which uniquely identifies this user's request for idempotent creation of a Team Drive. A repeated request by the same user and with the same request ID will avoid creating duplicates by attempting to create the same Team Drive. If the Team Drive already exists a 409 error will be returned.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/POST/query/requestId`.
                public var requestId: Swift.String
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - requestId: Required. An ID, such as a random UUID, which uniquely identifies this user's request for idempotent creation of a Team Drive. A repeated request by the same user and with the same request ID will avoid creating duplicates by attempting to create the same Team Drive. If the Team Drive already exists a 409 error will be returned.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    requestId: Swift.String
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.requestId = requestId
                }
            }
            public var query: Operations.Drive_teamdrives_create.Input.Query
            /// - Remark: Generated from `#/paths/teamdrives/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_create.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_create.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_teamdrives_create.Input.Headers
            /// - Remark: Generated from `#/paths/teamdrives/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/teamdrives/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.TeamDrive)
            }
            public var body: Operations.Drive_teamdrives_create.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                query: Operations.Drive_teamdrives_create.Input.Query,
                headers: Operations.Drive_teamdrives_create.Input.Headers = .init(),
                body: Operations.Drive_teamdrives_create.Input.Body? = nil
            ) {
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/teamdrives/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/teamdrives/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.TeamDrive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TeamDrive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_teamdrives_create.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_teamdrives_create.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//teamdrives/post(drive.teamdrives.create)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_teamdrives_create.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_teamdrives_create.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deprecated: Use `drives.get` instead.
    ///
    /// - Remark: HTTP `GET /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/get(drive.teamdrives.get)`.
    public enum Drive_teamdrives_get {
        public static let id: Swift.String = "drive.teamdrives.get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the Team Drive
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/path/teamDriveId`.
                public var teamDriveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - teamDriveId: The ID of the Team Drive
                public init(teamDriveId: Swift.String) {
                    self.teamDriveId = teamDriveId
                }
            }
            public var path: Operations.Drive_teamdrives_get.Input.Path
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_teamdrives_get.Input.Query
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_get.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_get.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_teamdrives_get.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.Drive_teamdrives_get.Input.Path,
                query: Operations.Drive_teamdrives_get.Input.Query = .init(),
                headers: Operations.Drive_teamdrives_get.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.TeamDrive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TeamDrive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_teamdrives_get.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_teamdrives_get.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/get(drive.teamdrives.get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_teamdrives_get.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_teamdrives_get.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deprecated: Use `drives.update` instead.
    ///
    /// - Remark: HTTP `PATCH /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/patch(drive.teamdrives.update)`.
    public enum Drive_teamdrives_update {
        public static let id: Swift.String = "drive.teamdrives.update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the Team Drive
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/path/teamDriveId`.
                public var teamDriveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - teamDriveId: The ID of the Team Drive
                public init(teamDriveId: Swift.String) {
                    self.teamDriveId = teamDriveId
                }
            }
            public var path: Operations.Drive_teamdrives_update.Input.Path
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/query/useDomainAdminAccess`.
                public var useDomainAdminAccess: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                ///   - useDomainAdminAccess: Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs.
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil,
                    useDomainAdminAccess: Swift.Bool? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                    self.useDomainAdminAccess = useDomainAdminAccess
                }
            }
            public var query: Operations.Drive_teamdrives_update.Input.Query
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_update.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Drive_teamdrives_update.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Drive_teamdrives_update.Input.Headers
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/requestBody/content/application\/json`.
                case json(Components.Schemas.TeamDrive)
            }
            public var body: Operations.Drive_teamdrives_update.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.Drive_teamdrives_update.Input.Path,
                query: Operations.Drive_teamdrives_update.Input.Query = .init(),
                headers: Operations.Drive_teamdrives_update.Input.Headers = .init(),
                body: Operations.Drive_teamdrives_update.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.TeamDrive)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TeamDrive {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Drive_teamdrives_update.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Drive_teamdrives_update.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/patch(drive.teamdrives.update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_teamdrives_update.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_teamdrives_update.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Deprecated: Use `drives.delete` instead.
    ///
    /// - Remark: HTTP `DELETE /teamdrives/{teamDriveId}`.
    /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/delete(drive.teamdrives.delete)`.
    public enum Drive_teamdrives_delete {
        public static let id: Swift.String = "drive.teamdrives.delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The ID of the Team Drive
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/path/teamDriveId`.
                public var teamDriveId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - teamDriveId: The ID of the Team Drive
                public init(teamDriveId: Swift.String) {
                    self.teamDriveId = teamDriveId
                }
            }
            public var path: Operations.Drive_teamdrives_delete.Input.Path
            /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/_.xgafv`.
                @frozen public enum __period_xgafv: String, Codable, Hashable, Sendable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                }
                /// V1 error format.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/$.xgafv`.
                public var _dollar__xgafv: Components.Parameters.__period_xgafv?
                /// OAuth access token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/access_token`.
                public var accessToken: Components.Parameters.AccessToken?
                /// - Remark: Generated from `#/components/parameters/alt`.
                @frozen public enum Alt: String, Codable, Hashable, Sendable, CaseIterable {
                    case json = "json"
                    case media = "media"
                    case proto = "proto"
                }
                /// Data format for response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/alt`.
                public var alt: Components.Parameters.Alt?
                /// JSONP
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/callback`.
                public var callback: Components.Parameters.Callback?
                /// Selector specifying which fields to include in a partial response.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/fields`.
                public var fields: Components.Parameters.Fields?
                /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/key`.
                public var key: Components.Parameters.Key?
                /// OAuth 2.0 token for the current user.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/oauth_token`.
                public var oauthToken: Components.Parameters.OauthToken?
                /// Returns response with indentations and line breaks.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/prettyPrint`.
                public var prettyPrint: Components.Parameters.PrettyPrint?
                /// Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/quotaUser`.
                public var quotaUser: Components.Parameters.QuotaUser?
                /// Upload protocol for media (e.g. "raw", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/upload_protocol`.
                public var uploadProtocol: Components.Parameters.UploadProtocol?
                /// Legacy upload protocol for media (e.g. "media", "multipart").
                ///
                /// - Remark: Generated from `#/paths/teamdrives/{teamDriveId}/DELETE/query/uploadType`.
                public var uploadType: Components.Parameters.UploadType?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _dollar__xgafv: V1 error format.
                ///   - accessToken: OAuth access token.
                ///   - alt: Data format for response.
                ///   - callback: JSONP
                ///   - fields: Selector specifying which fields to include in a partial response.
                ///   - key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
                ///   - oauthToken: OAuth 2.0 token for the current user.
                ///   - prettyPrint: Returns response with indentations and line breaks.
                ///   - quotaUser: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
                ///   - uploadProtocol: Upload protocol for media (e.g. "raw", "multipart").
                ///   - uploadType: Legacy upload protocol for media (e.g. "media", "multipart").
                public init(
                    _dollar__xgafv: Components.Parameters.__period_xgafv? = nil,
                    accessToken: Components.Parameters.AccessToken? = nil,
                    alt: Components.Parameters.Alt? = nil,
                    callback: Components.Parameters.Callback? = nil,
                    fields: Components.Parameters.Fields? = nil,
                    key: Components.Parameters.Key? = nil,
                    oauthToken: Components.Parameters.OauthToken? = nil,
                    prettyPrint: Components.Parameters.PrettyPrint? = nil,
                    quotaUser: Components.Parameters.QuotaUser? = nil,
                    uploadProtocol: Components.Parameters.UploadProtocol? = nil,
                    uploadType: Components.Parameters.UploadType? = nil
                ) {
                    self._dollar__xgafv = _dollar__xgafv
                    self.accessToken = accessToken
                    self.alt = alt
                    self.callback = callback
                    self.fields = fields
                    self.key = key
                    self.oauthToken = oauthToken
                    self.prettyPrint = prettyPrint
                    self.quotaUser = quotaUser
                    self.uploadProtocol = uploadProtocol
                    self.uploadType = uploadType
                }
            }
            public var query: Operations.Drive_teamdrives_delete.Input.Query
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            public init(
                path: Operations.Drive_teamdrives_delete.Input.Path,
                query: Operations.Drive_teamdrives_delete.Input.Query = .init()
            ) {
                self.path = path
                self.query = query
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/delete(drive.teamdrives.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Drive_teamdrives_delete.Output.Ok)
            /// Successful response
            ///
            /// - Remark: Generated from `#/paths//teamdrives/{teamDriveId}/delete(drive.teamdrives.delete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Drive_teamdrives_delete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
}
